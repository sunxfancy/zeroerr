// ====================================================================== lgtm [cpp/missing-header-guard]
// == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==
// ======================================================================
#pragma once


// If you just wish to use the color without dynamic
// enable or disable it, you can uncomment the following line
// #define ZEROERR_ALWAYS_COLORFUL
// #define ZEROERR_DISABLE_COLORFUL

// If you wish to use the whole library without thread safety, uncomment the following line
// #define ZEROERR_NO_THREAD_SAFE

// If you wish to disable auto initialization of the system
// #define ZEROERR_DISABLE_AUTO_INIT

// If you didn't wish override operator<< for ostream, we can disable it
// #define ZEROERR_DISABLE_OSTREAM_OVERRIDE

// Detect C++ standard
#if __cplusplus >= 201703L
#define ZEROERR_CXX_STANDARD 17
#elif __cplusplus >= 201402L
#define ZEROERR_CXX_STANDARD 14
#else
#define ZEROERR_CXX_STANDARD 11
#endif


#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
#define ZEROERR_OS_UNIX
#if defined(__linux__)
#define ZEROERR_OS_LINUX
#endif
#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
#define ZEROERR_OS_WINDOWS
#else
#define ZEROERR_OS_UNKNOWN
#endif


#if defined(NDEBUG) && !defined(ZEROERR_ALWAYS_ASSERT)
// FIXME: we should safely remove the assert in IF statement
// #define ZEROERR_NO_ASSERT
#endif

// This is used for generating a unique name based on the file name and line number
#define ZEROERR_CAT_IMPL(s1, s2) s1##s2
#define ZEROERR_CAT(x, s)        ZEROERR_CAT_IMPL(x, s)

// The following macros are used to check the arguments is empty or not
// from: https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/
#define _ARG16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) _15
#define HAS_COMMA(...)                                                                    _ARG16(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)
#define _TRIGGER_PARENTHESIS_(...)                                                        ,

#define ISEMPTY(...)                                                                               \
    _ISEMPTY(                        /* test if there is just one argument, eventually an empty    \
                                        one */                                                     \
             HAS_COMMA(__VA_ARGS__), /* test if _TRIGGER_PARENTHESIS_ together with the argument   \
                                        adds a comma */                                            \
             HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__), /* test if the argument together with a \
                                                              parenthesis adds a comma */          \
             HAS_COMMA(                                                                            \
                 __VA_ARGS__(/*empty*/)), /* test if placing it between _TRIGGER_PARENTHESIS_ and  \
                                             the parenthesis adds a comma */                       \
             HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__(/*empty*/)))

#define PASTE5(_0, _1, _2, _3, _4) _0##_1##_2##_3##_4
#define _ISEMPTY(_0, _1, _2, _3)   HAS_COMMA(PASTE5(_IS_EMPTY_CASE_, _0, _1, _2, _3))
#define _IS_EMPTY_CASE_0001        ,


// The counter is used to generate a unique name
#ifdef __COUNTER__
#define ZEROERR_NAMEGEN(x) ZEROERR_CAT(x, __COUNTER__)
#else  // __COUNTER__
#define ZEROERR_NAMEGEN(x) ZEROERR_CAT(x, __LINE__)
#endif  // __COUNTER__

#ifdef ZEROERR_OS_LINUX
#define ZEROERR_PERF
#endif

#ifdef ZEROERR_DISABLE_ASSERTS_RETURN_VALUES
#define ZEROERR_FUNC_SCOPE_BEGIN  do
#define ZEROERR_FUNC_SCOPE_END    while (0)
#define ZEROERR_FUNC_SCOPE_RET(v) (void)0
#else
#define ZEROERR_FUNC_SCOPE_BEGIN  [&]
#define ZEROERR_FUNC_SCOPE_END    ()
#define ZEROERR_FUNC_SCOPE_RET(v) return v
#endif

#ifndef ZEROERR_NO_SHORT_LOG_MACRO
#define ZEROERR_USE_SHORT_LOG_MACRO
#endif

#define ZEROERR_EXPAND(x) x

namespace zeroerr {
namespace detail {

// Generate sequence of integers from 0 to N-1
// Usage: detail::gen_seq<N>  then use <size_t... I> to match it
template <unsigned...>
struct seq {};

template <unsigned N, unsigned... Is>
struct gen_seq : gen_seq<N - 1, N - 1, Is...> {};

template <unsigned... Is>
struct gen_seq<0, Is...> : seq<Is...> {};

}  // namespace detail
}  // namespace zeroerr
#pragma once



namespace zeroerr {

#ifdef ZEROERR_ALWAYS_COLORFUL
constexpr const char* Reset      = "\x1b[0m";
constexpr const char* Bright     = "\x1b[1m";
constexpr const char* Dim        = "\x1b[2m";
constexpr const char* Underscore = "\x1b[4m";
constexpr const char* Blink      = "\x1b[5m";
constexpr const char* Reverse    = "\x1b[7m";
constexpr const char* Hidden     = "\x1b[8m";

constexpr const char* FgBlack   = "\x1b[30m";
constexpr const char* FgRed     = "\x1b[31m";
constexpr const char* FgGreen   = "\x1b[32m";
constexpr const char* FgYellow  = "\x1b[33m";
constexpr const char* FgBlue    = "\x1b[34m";
constexpr const char* FgMagenta = "\x1b[35m";
constexpr const char* FgCyan    = "\x1b[36m";
constexpr const char* FgWhite   = "\x1b[37m";

constexpr const char* BgBlack   = "\x1b[40m";
constexpr const char* BgRed     = "\x1b[41m";
constexpr const char* BgGreen   = "\x1b[42m";
constexpr const char* BgYellow  = "\x1b[43m";
constexpr const char* BgBlue    = "\x1b[44m";
constexpr const char* BgMagenta = "\x1b[45m";
constexpr const char* BgCyan    = "\x1b[46m";
constexpr const char* BgWhite   = "\x1b[47m";

#elif defined(ZEROERR_DISABLE_COLORFUL)
constexpr const char* Reset      = "";
constexpr const char* Bright     = "";
constexpr const char* Dim        = "";
constexpr const char* Underscore = "";
constexpr const char* Blink      = "";
constexpr const char* Reverse    = "";
constexpr const char* Hidden     = "";

constexpr const char* FgBlack   = "";
constexpr const char* FgRed     = "";
constexpr const char* FgGreen   = "";
constexpr const char* FgYellow  = "";
constexpr const char* FgBlue    = "";
constexpr const char* FgMagenta = "";
constexpr const char* FgCyan    = "";
constexpr const char* FgWhite   = "";

constexpr const char* BgBlack   = "";
constexpr const char* BgRed     = "";
constexpr const char* BgGreen   = "";
constexpr const char* BgYellow  = "";
constexpr const char* BgBlue    = "";
constexpr const char* BgMagenta = "";
constexpr const char* BgCyan    = "";
constexpr const char* BgWhite   = "";
#else
extern const char* Reset;
extern const char* Bright;
extern const char* Dim;
extern const char* Underscore;
extern const char* Blink;
extern const char* Reverse;
extern const char* Hidden;

extern const char* FgBlack;
extern const char* FgRed;
extern const char* FgGreen;
extern const char* FgYellow;
extern const char* FgBlue;
extern const char* FgMagenta;
extern const char* FgCyan;
extern const char* FgWhite;

extern const char* BgBlack;
extern const char* BgRed;
extern const char* BgGreen;
extern const char* BgYellow;
extern const char* BgBlue;
extern const char* BgMagenta;
extern const char* BgCyan;
extern const char* BgWhite;

extern void disableColorOutput();
extern void enableColorOutput();

#endif

}  // namespace zeroerr

#pragma once



namespace zeroerr {

enum OutputStream { STDOUT, STDERR };
extern bool isTerminalOutput(OutputStream stream);


struct TerminalSize {
    int width;
    int height;
};
TerminalSize getTerminalSize();

}  // namespace zeroerr

/* Copyright (c) 2011-2021, Scott Tsai
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef DEBUG_BREAK_H
#define DEBUG_BREAK_H

#ifdef _MSC_VER

#define debug_break __debugbreak

#else

#ifdef __cplusplus
extern "C" {
#endif

#define DEBUG_BREAK_USE_TRAP_INSTRUCTION 1
#define DEBUG_BREAK_USE_BULTIN_TRAP      2
#define DEBUG_BREAK_USE_SIGTRAP          3

#if defined(__i386__) || defined(__x86_64__)
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
__inline__ static void trap_instruction(void) { __asm__ volatile("int $0x03"); }
#elif defined(__thumb__)
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
/* FIXME: handle __THUMB_INTERWORK__ */
__attribute__((always_inline)) __inline__ static void trap_instruction(void) {
    /* See 'arm-linux-tdep.c' in GDB source.
     * Both instruction sequences below work. */
#if 1
    /* 'eabi_linux_thumb_le_breakpoint' */
    __asm__ volatile(".inst 0xde01");
#else
    /* 'eabi_linux_thumb2_le_breakpoint' */
    __asm__ volatile(".inst.w 0xf7f0a000");
#endif

    /* Known problem:
     * After a breakpoint hit, can't 'stepi', 'step', or 'continue' in GDB.
     * 'step' would keep getting stuck on the same instruction.
     *
     * Workaround: use the new GDB commands 'debugbreak-step' and
     * 'debugbreak-continue' that become available
     * after you source the script from GDB:
     *
     * $ gdb -x debugbreak-gdb.py <... USUAL ARGUMENTS ...>
     *
     * 'debugbreak-step' would jump over the breakpoint instruction with
     * roughly equivalent of:
     * (gdb) set $instruction_len = 2
     * (gdb) tbreak *($pc + $instruction_len)
     * (gdb) jump   *($pc + $instruction_len)
     */
}
#elif defined(__arm__) && !defined(__thumb__)
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
__attribute__((always_inline)) __inline__ static void trap_instruction(void) {
    /* See 'arm-linux-tdep.c' in GDB source,
     * 'eabi_linux_arm_le_breakpoint' */
    __asm__ volatile(".inst 0xe7f001f0");
    /* Known problem:
     * Same problem and workaround as Thumb mode */
}
#elif defined(__aarch64__) && defined(__APPLE__)
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_BULTIN_DEBUGTRAP
#elif defined(__aarch64__)
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
__attribute__((always_inline)) __inline__ static void trap_instruction(void) {
    /* See 'aarch64-tdep.c' in GDB source,
     * 'aarch64_default_breakpoint' */
    __asm__ volatile(".inst 0xd4200000");
}
#elif defined(__powerpc__)
/* PPC 32 or 64-bit, big or little endian */
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
__attribute__((always_inline)) __inline__ static void trap_instruction(void) {
    /* See 'rs6000-tdep.c' in GDB source,
     * 'rs6000_breakpoint' */
    __asm__ volatile(".4byte 0x7d821008");

    /* Known problem:
     * After a breakpoint hit, can't 'stepi', 'step', or 'continue' in GDB.
     * 'step' stuck on the same instruction ("twge r2,r2").
     *
     * The workaround is the same as ARM Thumb mode: use debugbreak-gdb.py
     * or manually jump over the instruction. */
}
#elif defined(__riscv)
/* RISC-V 32 or 64-bit, whether the "C" extension
 * for compressed, 16-bit instructions are supported or not */
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION
__attribute__((always_inline)) __inline__ static void trap_instruction(void) {
    /* See 'riscv-tdep.c' in GDB source,
     * 'riscv_sw_breakpoint_from_kind' */
    __asm__ volatile(".4byte 0x00100073");
}
#else
#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_SIGTRAP
#endif


#ifndef DEBUG_BREAK_IMPL
#error "debugbreak.h is not supported on this target"
#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_TRAP_INSTRUCTION
__attribute__((always_inline)) __inline__ static void debug_break(void) { trap_instruction(); }
#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_BULTIN_DEBUGTRAP
__attribute__((always_inline)) __inline__ static void debug_break(void) { __builtin_debugtrap(); }
#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_BULTIN_TRAP
__attribute__((always_inline)) __inline__ static void debug_break(void) { __builtin_trap(); }
#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_SIGTRAP
#include <signal.h>
__attribute__((always_inline)) __inline__ static void debug_break(void) { raise(SIGTRAP); }
#else
#error "invalid DEBUG_BREAK_IMPL value"
#endif

#ifdef __cplusplus
}
#endif

#endif /* ifdef _MSC_VER */


// Here is for checking the debugger is running

#include <fstream>

#ifdef IS_DEBUGGER_ACTIVE
__attribute__((always_inline)) __inline__ static bool isDebuggerActive() {
    return IS_DEBUGGER_ACTIVE();
}
#else  // IS_DEBUGGER_ACTIVE
#ifdef __linux__
class ErrnoGuard {
public:
    ErrnoGuard() : m_oldErrno(errno) {}
    ~ErrnoGuard() { errno = m_oldErrno; }

private:
    int m_oldErrno;
};
// See the comments in Catch2 for the reasoning behind this implementation:
// https://github.com/catchorg/Catch2/blob/v2.13.1/include/internal/catch_debugger.cpp#L79-L102
__attribute__((always_inline)) __inline__ static bool isDebuggerActive() {
    ErrnoGuard    guard;
    std::ifstream in("/proc/self/status");
    for (std::string line; std::getline(in, line);) {
        static const int PREFIX_LEN = 11;
        if (line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0) {
            return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
        }
    }
    return false;
}
#elif defined(__APPLE__)
// The following function is taken directly from the following technical note:
// https://developer.apple.com/library/archive/qa/qa1361/_index.html
// Returns true if the current process is being debugged (either
// running under the debugger or has a debugger attached post facto).
__attribute__((always_inline)) __inline__ static bool isDebuggerActive() {
    int        mib[4];
    kinfo_proc info;
    size_t     size;
    // Initialize the flags so that, if sysctl fails for some bizarre
    // reason, we get a predictable result.
    info.kp_proc.p_flag = 0;
    // Initialize mib, which tells sysctl the info we want, in this case
    // we're looking for information about a specific process ID.
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = getpid();
    // Call sysctl.
    size = sizeof(info);
    if (sysctl(mib, (sizeof(mib) / sizeof(*mib)), &info, &size, 0, 0) != 0) {
        std::cerr << "\nCall to sysctl failed - unable to determine if debugger is active **\n";
        return false;
    }
    // We're being debugged if the P_TRACED flag is set.
    return ((info.kp_proc.p_flag & P_TRACED) != 0);
}
#elif defined(__MINGW32__) || defined(__MINGW64__)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
__attribute__((always_inline)) __inline__  static bool isDebuggerActive() {
    return ::IsDebuggerPresent() != 0;
}
#elif defined(_MSC_VER)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
inline __forceinline static bool isDebuggerActive() {
    return ::IsDebuggerPresent() != 0;
}
#else

__attribute__((always_inline)) __inline__ static bool isDebuggerActive() { return false; }
#endif
#endif  // IS_DEBUGGER_ACTIVE


#endif /* ifndef DEBUG_BREAK_H */
#pragma once


// Thread safety support
#ifdef ZEROERR_NO_THREAD_SAFE

#define ZEROERR_MUTEX(x)
#define ZEROERR_LOCK(x)
#define ZEROERR_ATOMIC(x) x
#else

#define ZEROERR_MUTEX(x)  static std::mutex x;
#define ZEROERR_LOCK(x)   std::lock_guard<std::mutex> lock(x);
#define ZEROERR_ATOMIC(x) std::atomic<x>

#include <atomic>
#include <mutex>

#endif

#pragma once




#include <ostream>
#include <sstream>
#include <string>
#include <tuple>  // this should be removed
#include <type_traits>
#ifdef __GNUG__
#include <cxxabi.h>
#endif

#if defined(ZEROERR_ENABLE_PFR) && (ZEROERR_CXX_STANDARD >= 14)
#include "pfr.hpp"
#endif

#if defined(ZEROERR_ENABLE_MAGIC_ENUM) && (ZEROERR_CXX_STANDARD >= 17)
#include "magic_enum.hpp"
#endif

#if defined(ZEROERR_ENABLE_DSVIZ) 
#include "dsviz.h"
#endif

// those predefines can help to avoid include too many headers
namespace std {
template <typename T>
class complex;

template <class T, class Deleter>
class unique_ptr;

template <class T>
class shared_ptr;

template <class T>
class weak_ptr;

}  // namespace std

namespace zeroerr {

#pragma region type traits

struct Printer;

template <unsigned N>
struct rank : rank<N - 1> {};
template <>
struct rank<0> {};
constexpr unsigned max_rank = 5;


template <typename T>
void PrinterExt(Printer&, T, unsigned, const char*, rank<0>);


namespace detail {

// C++11 void_t
template <typename... Ts>
using void_t = void;


// Some utility structs to check template specialization
template <typename Test, template <typename...> class Ref>
struct is_specialization : std::false_type {};

template <template <typename...> class Ref, typename... Args>
struct is_specialization<Ref<Args...>, Ref> : std::true_type {};


// Check if a type is stream writable, i.e., std::cout << foo;
// Usage: is_streamable<std::ostream, int>::value
template <typename S, typename T, typename = void>
struct is_streamable : std::false_type {};

template <typename S, typename T>
struct is_streamable<S, T, void_t<decltype(std::declval<S&>() << std::declval<T>())>>
    : std::true_type {};


// Check if a type is a container type
// Usage: is_container<std::vector<int>>::value
template <typename T, typename = void>
struct is_container : std::false_type {};

template <typename T>
struct is_container<T,
                    void_t<decltype(std::declval<T>().begin()), decltype(std::declval<T>().end())>>
    : std::true_type {};

#if ZEROERR_CXX_STANDARD >= 17
#define ZEROERR_STRING_VIEW std::is_same<T, std::string_view>::value
#else
#define ZEROERR_STRING_VIEW 0
#endif

// Check if a type is a string type
template <class T>
struct is_string
    : std::integral_constant<bool, std::is_same<T, std::string>::value ||
                                       std::is_same<T, const char*>::value || ZEROERR_STRING_VIEW> {
};


// Check if a type can use arr[0] like an array
template <typename T, typename = void>
struct is_array : std::false_type {};

template <typename T>
struct is_array<T, void_t<decltype(std::declval<T>()[0])>> : std::true_type {};


// Check if a type has the element type as std::pair
template <typename T, typename = void>
struct ele_type_is_pair : std::false_type {};

template <typename T>
struct ele_type_is_pair<
    T, void_t<typename T::value_type, decltype(std::declval<typename T::value_type>().first),
              decltype(std::declval<typename T::value_type>().second)>> : std::true_type {};

template <typename T, typename = void>
struct has_extension : std::false_type {};

template <typename T>
struct has_extension<
    T, void_t<decltype(zeroerr::PrinterExt(std::declval<zeroerr::Printer&>(), std::declval<T&>(), 0,
                                           nullptr, zeroerr::rank<zeroerr::max_rank>()))>>
    : std::true_type {};



#define ZEROERR_ENABLE_IF(x) \
    template <typename T>    \
    typename std::enable_if<x, void>::type
#define ZEROERR_IS_INT        std::is_integral<T>::value
#define ZEROERR_IS_FLOAT      std::is_floating_point<T>::value
#define ZEROERR_IS_CONTAINER  detail::is_container<T>::value
#define ZEROERR_IS_STRING     detail::is_string<T>::value
#define ZEROERR_IS_POINTER    std::is_pointer<T>::value
#define ZEROERR_IS_CHAR       std::is_same<T, char>::value
#define ZEROERR_IS_WCHAR      std::is_same<T, wchar_t>::value
#define ZEROERR_IS_CLASS      std::is_class<T>::value
#define ZEROERR_IS_STREAMABLE detail::is_streamable<std::ostream, T>::value
#define ZEROERR_IS_ARRAY      detail::is_array<T>::value
#define ZEROERR_IS_COMPLEX    detail::is_specialization<T, std::complex>::value
#define ZEROERR_IS_BOOL       std::is_same<T, bool>::value
#define ZEROERR_IS_AUTOPTR                                   \
    (detail::is_specialization<T, std::unique_ptr>::value || \
     detail::is_specialization<T, std::shared_ptr>::value || \
     detail::is_specialization<T, std::weak_ptr>::value)
#define ZEROERR_IS_MAP detail::ele_type_is_pair<T>::value
#define ZEROERR_IS_POD std::is_standard_layout<T>::value
#define ZEROERR_IS_EXT detail::has_extension<T>::value

}  // namespace detail
#pragma endregion


/**
 * @brief A functor class Printer for printing a value of any type.
 *
 * This class can print values with all basic types, pointers, STL containers, tuple, optional, and
 * variant values. Any class that is streamable can be printed. POD structs can be supported using
 * third-party library Boost.PFR and enum can be supported using magic_enum.
 */
struct Printer {
    template <typename... Args>
    Printer& operator()(Args&&... args) {
        check_stream();
        call(std::forward<Args>(args)...);
        return *this;
    }
    template <typename T>
    Printer& operator()(std::initializer_list<T>&& value) {
        check_stream();
        call(std::forward<decltype(value)>(value));
        return *this;
    }

    void check_stream() {
        if (use_stringstream && clear_stream_before_printing) {
            auto& ss = static_cast<std::stringstream&>(os);
            ss.str(std::string());
            ss.clear();
        }
    }

    template <typename T, typename... V>
    void call(T value, V... others) {
        PrinterExt(*this, std::forward<T>(value), 0, " ", rank<max_rank>{});
        call(std::forward<V>(others)...);
    }

    template <typename T>
    void call(T value) {
        PrinterExt(*this, std::forward<T>(value), 0, "", rank<max_rank>{});
        os << line_break;
        os.flush();
    }

    Printer(std::ostream& os) : os(os) {}
    Printer() : os(*new std::stringstream()) { use_stringstream = true; }
    ~Printer() {
        if (use_stringstream) delete &os;
    }

    bool          isColorful = true;   // colorful output
    bool          isCompact  = false;  // compact mode
    bool          isQuoted   = true;   // string is quoted
    int           indent     = 2;
    const char*   line_break = "\n";
    std::ostream& os;
    bool          use_stringstream             = false;
    bool          clear_stream_before_printing = true;

    template <class T>
    static std::string type(const T& t) {
        return demangle(typeid(t).name());
    }


    ZEROERR_ENABLE_IF(ZEROERR_IS_INT || ZEROERR_IS_FLOAT)
    print(T value, unsigned level, const char* lb, rank<0>) { os << tab(level) << value << lb; }

    ZEROERR_ENABLE_IF(ZEROERR_IS_POINTER)
    print(T value, unsigned level, const char* lb, rank<0>) {
        if (value == nullptr)
            os << tab(level) << "nullptr" << lb;
        else
            os << tab(level) << "<" << type(value) << " at " << value << ">" << lb;
    }


    ZEROERR_ENABLE_IF(ZEROERR_IS_CLASS)
    print(T value, unsigned level, const char* lb, rank<0>) {
        os << tab(level) << "Object " << type(value) << lb;
    }


    ZEROERR_ENABLE_IF(ZEROERR_IS_CHAR || ZEROERR_IS_WCHAR)
    print(T value, unsigned level, const char* lb, rank<1>) {
        os << tab(level) << '\'' << value << '\'' << lb;
    }

#if defined(ZEROERR_ENABLE_PFR) && (ZEROERR_CXX_STANDARD >= 14)
    template <class StructType, unsigned... I>
    void print_struct(const StructType& s, unsigned level, const char* lb, detail::seq<I...>) {
        int a[] = {(os << (I == 0 ? "" : ", ") << pfr::get<I>(s), 0)...};
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_CLASS&& ZEROERR_IS_POD)
    print(const T& value, unsigned level, const char* lb, rank<1>) {
        os << tab(level) << "{";
        print_struct(value, level, isCompact ? " " : line_break,
                     detail::gen_seq<pfr::tuple_size<T>::value>{});
        os << tab(level) << "}" << lb;
    }
#endif

    ZEROERR_ENABLE_IF(ZEROERR_IS_BOOL)
    print(T value, unsigned level, const char* lb, rank<2>) {
        os << tab(level) << (value ? "true" : "false") << lb;
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_CLASS&& ZEROERR_IS_STREAMABLE)
    print(T value, unsigned level, const char* lb, rank<2>) { os << tab(level) << value << lb; }


    ZEROERR_ENABLE_IF(ZEROERR_IS_CONTAINER)
    print(const T& value, unsigned level, const char* lb, rank<2>) {
        os << tab(level) << "{" << (isCompact ? "" : line_break);
        bool last = false;
        for (auto iter = value.begin(); iter != value.end(); ++iter) {
            if (std::next(iter) == value.end()) last = true;
            print(*iter, level + 1, isCompact ? (last ? "" : ", ") : line_break, rank<max_rank>{});
        }
        os << tab(level) << "}" << lb;
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_CONTAINER&& ZEROERR_IS_ARRAY)
    print(const T& value, unsigned level, const char* lb, rank<3>) {
        os << tab(level) << "[";
        bool last = false;
        for (auto iter = value.begin(); iter != value.end(); ++iter) {
            if (std::next(iter) == value.end()) last = true;
            print(*iter, 0, last ? "" : ", ", rank<max_rank>{});
        }
        os << tab(level) << "]" << lb;
    }


    ZEROERR_ENABLE_IF(ZEROERR_IS_AUTOPTR)
    print(T value, unsigned level, const char* lb, rank<3> r) {
        if (value.get() == nullptr)
            os << tab(level) << "nullptr" << lb;
        else
            os << tab(level) << "<" << type(value) << " at " << value.get() << ">" << lb;
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_CONTAINER&& ZEROERR_IS_MAP)
    print(const T& value, unsigned level, const char* lb, rank<4>) {
        os << tab(level) << "{" << (isCompact ? "" : line_break);
        bool last = false;
        for (auto iter = value.begin(); iter != value.end(); ++iter) {
            if (std::next(iter) == value.end()) last = true;
            print(iter->first, level + 1, " : ", rank<max_rank>{});
            print(iter->second, level + 1, isCompact ? (last ? "" : ", ") : line_break,
                  rank<max_rank>{});
        }
        os << tab(level) << "}" << lb;
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_COMPLEX)
    print(T value, unsigned level, const char* lb, rank<4>) {
        os << tab(level) << "(" << value.real() << "+" << value.imag() << "i)" << lb;
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_STRING)
    print(T value, unsigned level, const char* lb, rank<4>) {
        os << tab(level) << quote() << value << quote() << lb;
    }

    template <class TupType>
    inline void print_tuple(const TupType& _tup, unsigned level, const char* lb,
                            detail::seq<>) {
    }

    template <class TupType, unsigned... I>
    inline void print_tuple(const TupType& _tup, unsigned level, const char* lb,
                            detail::seq<I...>) {
        int a[] = {(os << (I == 0 ? "" : ", ") << std::get<I>(_tup), 0)...};
    }

    template <class... Args>
    void print(const std::tuple<Args...>& value, unsigned level, const char* lb, rank<3> r) {
        os << tab(level) << "(";
        print_tuple(value, level, isCompact ? " " : line_break, detail::gen_seq<sizeof...(Args)>{});
        os << ")" << lb;
    }

    std::string tab(unsigned level) { return std::string((isCompact ? 0 : level * indent), ' '); }
    const char* quote() { return isQuoted ? "\"" : ""; }

    static std::string demangle(const char* name) {
#ifdef __GNUG__
        int         status = -4;
        char*       res    = abi::__cxa_demangle(name, NULL, NULL, &status);
        std::string ret    = (status == 0) ? res : name;
        std::free(res);
        return ret;
#else
        return name;
#endif
    }

    std::string str() const { return static_cast<std::stringstream&>(os).str(); }
    operator std::string() const { return str(); }

    friend std::ostream& operator<<(std::ostream& os, const Printer& P) {
        if (P.use_stringstream) os << P.str();
        return os;
    }
};

/**
 * @brief PrinterExt is an extension of Printer that allows user to write custom rules for printing.
 * User can use SFINAE to extend PrinterExt, e.g.:
 * template <typename T>
 * typename std::enable_if<std::is_base_of<llvm::Function, T>::value, void>::type
 * PrinterExt(Printer& P, T* s, unsigned level, const char* lb, rank<3>);
 *
 * @tparam T the type of the object to be printed.
 * @param P Printer class
 * @param v the object to be printed.
 * @param level the indentation level.
 * @param lb  the line break.
 * @param r  the rank of the rule. 0 is lowest priority.
 */
template <class T>
void PrinterExt(Printer& P, T v, unsigned level, const char* lb, rank<0> r) {
    P.print(std::forward<T>(v), level, lb, rank<max_rank>{});
}

extern Printer& getStdoutPrinter();
extern Printer& getStderrPrinter();


}  // namespace zeroerr

#pragma once




#define AND &&zeroerr::ExpressionDecomposer() <<
#define OR  || zeroerr::ExpressionDecomposer() <<

namespace zeroerr {

#pragma region expression decompostion

// SFINAE helper used to check L op R is supported, but the result type is `ret`
#define ZEROERR_SFINAE_OP(ret, op) \
    typename std::decay<decltype(std::declval<L>() op std::declval<R>(), std::declval<ret>())>::type

template <typename T>
struct deferred_false {
    static const bool value = false;
};

#define ZEROERR_EXPRESSION_COMPARISON(op, op_name)                                           \
    template <typename R>                                                                    \
    ZEROERR_SFINAE_OP(Expression<typename std::decay<R>::type>, op)                          \
    operator op(R&& rhs) {                                                                   \
        std::stringstream ss;                                                                \
        Printer           print(ss);                                                         \
        print.isCompact  = true;                                                             \
        print.line_break = "";                                                               \
        if (decomp.empty()) {                                                                \
            print(lhs);                                                                      \
            res = true;                                                                      \
        } else                                                                               \
            ss << decomp;                                                                    \
        ss << " " #op " ";                                                                   \
        print(rhs);                                                                          \
        return Expression<typename std::decay<R>::type>(                                     \
            std::forward<typename std::decay<R>::type>(rhs), res && (lhs op rhs), ss.str()); \
    }

#define ZEROERR_EXPRESSION_ANDOR(op, op_name)        \
    ExprResult operator op(ExprResult rhs) {         \
        std::stringstream ss;                        \
        ss << decomp << " " #op " " << rhs.decomp;   \
        return ExprResult(res op rhs.res, ss.str()); \
    }


#define ZEROERR_FORBIT_EXPRESSION(rt, op)                                 \
    template <typename R>                                                 \
    rt& operator op(const R&) {                                           \
        static_assert(deferred_false<R>::value,                           \
                      "Please Rewrite Expression As Binary Comparison!"); \
        return *this;                                                     \
    }

struct ExprResult {
    bool        res;
    std::string decomp;

    ExprResult(bool res, std::string decomposition = "") : res(res), decomp(decomposition) {}

    ZEROERR_EXPRESSION_ANDOR(&&, and)
    ZEROERR_EXPRESSION_ANDOR(||, or)

    ZEROERR_FORBIT_EXPRESSION(ExprResult, &)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, ^)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, |)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, ==)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, !=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, <)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, >)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, <=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, >=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, +=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, -=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, *=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, /=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, %=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, <<=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, >>=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, &=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, ^=)
    ZEROERR_FORBIT_EXPRESSION(ExprResult, |=)
};

template <typename L>
struct Expression {
    L           lhs;
    bool        res = true;
    std::string decomp;

    explicit Expression(L&& in) : lhs(std::forward<L>(in)) { res = static_cast<bool>(lhs); }
    explicit Expression(L&& in, bool res, std::string&& decomp)
        : lhs(std::forward<L>(in)), res(res), decomp(std::forward<std::string>(decomp)) {}

    operator ExprResult() {
        if (decomp.empty()) {
            Printer print;
            print.isCompact  = true;
            print.line_break = "";
            decomp           = print(lhs).str();
        }
        return ExprResult(res, decomp);
    }

    operator L() const { return lhs; }

    ZEROERR_EXPRESSION_COMPARISON(==, eq)
    ZEROERR_EXPRESSION_COMPARISON(!=, ne)
    ZEROERR_EXPRESSION_COMPARISON(>, gt)
    ZEROERR_EXPRESSION_COMPARISON(<, lt)
    ZEROERR_EXPRESSION_COMPARISON(>=, ge)
    ZEROERR_EXPRESSION_COMPARISON(<=, le)

    ZEROERR_EXPRESSION_ANDOR(&&, and)
    ZEROERR_EXPRESSION_ANDOR(||, or)

    ZEROERR_FORBIT_EXPRESSION(Expression, &)
    ZEROERR_FORBIT_EXPRESSION(Expression, ^)
    ZEROERR_FORBIT_EXPRESSION(Expression, |)
    ZEROERR_FORBIT_EXPRESSION(Expression, &&)
    ZEROERR_FORBIT_EXPRESSION(Expression, ||)
    ZEROERR_FORBIT_EXPRESSION(Expression, =)
    ZEROERR_FORBIT_EXPRESSION(Expression, +=)
    ZEROERR_FORBIT_EXPRESSION(Expression, -=)
    ZEROERR_FORBIT_EXPRESSION(Expression, *=)
    ZEROERR_FORBIT_EXPRESSION(Expression, /=)
    ZEROERR_FORBIT_EXPRESSION(Expression, %=)
    ZEROERR_FORBIT_EXPRESSION(Expression, <<=)
    ZEROERR_FORBIT_EXPRESSION(Expression, >>=)
    ZEROERR_FORBIT_EXPRESSION(Expression, &=)
    ZEROERR_FORBIT_EXPRESSION(Expression, ^=)
    ZEROERR_FORBIT_EXPRESSION(Expression, |=)
    ZEROERR_FORBIT_EXPRESSION(Expression, <<)
    ZEROERR_FORBIT_EXPRESSION(Expression, >>)
};

struct ExpressionDecomposer {
    // The right operator for capturing expressions is "<=" instead of "<<" (based on the
    // operator precedence table) but then there will be warnings from GCC about "-Wparentheses"
    // and since "_Pragma()" is problematic this will stay for now...
    // https://github.com/catchorg/Catch2/issues/870
    // https://github.com/catchorg/Catch2/issues/565
    template <typename L>
    Expression<L> operator<<(L&& operand) {
        return Expression<L>(std::forward<L>(operand));
    }
};

#pragma endregion


#pragma region matcher


template <typename T>
class IMatcher {
public:
    virtual ~IMatcher() = default;


    virtual bool match(const T&) const = 0;
};

template <typename T>
class IMatcherRef {
public:
    IMatcherRef(const IMatcher<T>* ptr) : p(ptr) {}
    IMatcherRef(const IMatcherRef&) = delete;

    IMatcherRef(IMatcherRef&& other) {
        p       = std::move(other.p);
        other.p = nullptr;
    }
    void operator=(IMatcherRef&& other) {
        p       = std::move(other.p);
        other.p = nullptr;
    }
    IMatcherRef& operator=(const IMatcherRef&) = delete;
    ~IMatcherRef() {
        if (p) delete p;
    }


    IMatcherRef operator&&(IMatcherRef&& other);
    IMatcherRef operator||(IMatcherRef&& other);
    IMatcherRef operator!();

    const IMatcher<T>* operator->() const { return p; }

protected:
    const IMatcher<T>* p = nullptr;
};


template <typename T>
class CombinedMatcher : public IMatcher<T> {
public:
    CombinedMatcher(IMatcherRef<T>&& lhs, IMatcherRef<T>&& rhs, bool is_and)
        : lhs(std::move(lhs)), rhs(std::move(rhs)), is_and(is_and) {}

    IMatcherRef<T> lhs;
    IMatcherRef<T> rhs;
    bool           is_and;

    virtual bool match(const T& t) const override {
        if (is_and) {
            return lhs->match(t) && rhs->match(t);
        } else {
            return lhs->match(t) || rhs->match(t);
        }
    }
};

template <typename T>
class NotMatcher : public IMatcher<T> {
public:
    NotMatcher(IMatcherRef<T>&& matcher) : matcher(std::move(matcher)) {}
    IMatcherRef<T> matcher;

    virtual bool match(const T& t) const override { return !matcher->match(t); }
};

template <typename T>
inline IMatcherRef<T> IMatcherRef<T>::operator&&(IMatcherRef<T>&& other) {
    return new CombinedMatcher<T>(std::move(*this), std::move(other), true);
}

template <typename T>
inline IMatcherRef<T> IMatcherRef<T>::operator||(IMatcherRef<T>&& other) {
    return new CombinedMatcher<T>(std::move(*this), std::move(other), false);
}

template <typename T>
inline IMatcherRef<T> IMatcherRef<T>::operator!() {
    return new NotMatcher<T>(std::move(*this));
}


template <typename T>
struct StartWithMatcher : public IMatcher<T> {
    StartWithMatcher(const T& s) : start(s) {}
    T start;

    virtual bool match(const T& t) const override {
        bool result = true;
        for (auto i = start.begin(), j = t.begin(); i != start.end(); ++i, ++j) {
            if (j == t.end() || *i != *j) {
                result = false;
                break;
            }
        }
        return result;
    }
};

template <typename T>
typename std::enable_if<std::is_constructible<std::string, T>::value,
                        IMatcherRef<std::string>>::type
start_with(T&& s) {
    return new StartWithMatcher<std::string>(std::string(s));
}


#pragma endregion


}  // namespace zeroerr
/*
 * This benchmark component is modified from nanobench by Martin Ankerl
 * https://github.com/martinus/nanobench
 */

#pragma once


#include <chrono>
#include <cstdint>
#include <string>
#include <vector>

namespace zeroerr {


#pragma region Benchmark


template <typename T>
struct PerfCountSet {
    T iterations{};
    T data[7]{};

    T& timeElapsed() { return data[0]; }
    T& pageFaults() { return data[1]; }
    T& cpuCycles() { return data[2]; }
    T& contextSwitches() { return data[3]; }
    T& instructions() { return data[4]; }
    T& branchInstructions() { return data[5]; }
    T& branchMisses() { return data[6]; }
};

using Clock = std::conditional<std::chrono::high_resolution_clock::is_steady,
                               std::chrono::high_resolution_clock, std::chrono::steady_clock>::type;

namespace detail {
struct LinuxPerformanceCounter;
}

struct PerformanceCounter {
    PerformanceCounter();
    ~PerformanceCounter();

    void beginMeasure();
    void endMeasure();
    void updateResults(uint64_t numIters);

    PerfCountSet<uint64_t> const& val() const noexcept { return _val; }
    PerfCountSet<bool>            has() const noexcept { return _has; }

    static PerformanceCounter& inst();

    Clock::duration elapsed;

protected:
    Clock::time_point      _start;
    PerfCountSet<uint64_t> _val;
    PerfCountSet<bool>     _has;

    detail::LinuxPerformanceCounter* _perf = nullptr;
};


struct BenchResult {
    enum Measure {
        time_elapsed        = 1 << 0,
        iterations          = 1 << 1,
        page_faults         = 1 << 2,
        cpu_cycles          = 1 << 3,
        context_switches    = 1 << 4,
        instructions        = 1 << 5,
        branch_instructions = 1 << 6,
        branch_misses       = 1 << 7,
        all                 = (1 << 8) - 1,
    };
    std::string                       name;
    std::vector<PerfCountSet<double>> epoch_details;
    PerfCountSet<bool>                has;

    PerfCountSet<double> average() const;
    PerfCountSet<double> min() const;
    PerfCountSet<double> max() const;
    PerfCountSet<double> mean() const;
};

struct Benchmark;
struct BenchState;
BenchState* createBenchState(Benchmark& benchmark);
void        destroyBenchState(BenchState* state);

size_t getNumIter(BenchState* state);
void   runIteration(BenchState* state);
void   moveResult(BenchState* state, std::string name);


/**
 * @brief Benchmark create a core object for configuration of a benchmark.
 * This class is a driver to run multiple times of a benchmark. Each time of a run will generate a
 * row of data. Report will print the data in console.
 */
struct Benchmark {
    std::string title          = "benchmark";
    const char* op_unit        = "op";
    const char* time_unit      = "ns";
    uint64_t    epochs         = 10;
    uint64_t    warmup         = 0;
    uint64_t    iter_per_epoch = 0;

    using ns   = std::chrono::nanoseconds;
    using ms   = std::chrono::milliseconds;
    using time = ns;

    time mMaxEpochTime = ms(100);
    time mMinEpochTime = ms(1);

    uint64_t minimalResolutionMutipler = 1000;

    Benchmark(std::string title) { this->title = title; }


    template <typename Op>
    Benchmark& run(std::string name, Op&& op) {
        auto* s  = createBenchState(*this);
        auto& pc = PerformanceCounter::inst();
        while (auto n = getNumIter(s)) {
            pc.beginMeasure();
            while (n-- > 0) op();
            pc.endMeasure();
            runIteration(s);
        }
        moveResult(s, name);
        return *this;
    }

    template <typename Op>
    Benchmark& run(Op&& op) {
        return run("", std::forward<Op>(op));
    }

    std::vector<BenchResult> result;
    void                     report();
};


#pragma endregion

#pragma region details


namespace detail {

#if defined(_MSC_VER)
void doNotOptimizeAwaySink(void const*);

template <typename T>
void doNotOptimizeAway(T const& val) {
    doNotOptimizeAwaySink(&val);
}

#else

// These assembly magic is directly from what Google Benchmark is doing. I have previously used
// what facebook's folly was doing, but this seemed to have compilation problems in some cases.
// Google Benchmark seemed to be the most well tested anyways. see
// https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307
template <typename T>
void doNotOptimizeAway(T const& val) {
    // NOLINTNEXTLINE(hicpp-no-assembler)
    asm volatile("" : : "r,m"(val) : "memory");
}

template <typename T>
void doNotOptimizeAway(T& val) {
#if defined(__clang__)
    // NOLINTNEXTLINE(hicpp-no-assembler)
    asm volatile("" : "+r,m"(val) : : "memory");
#else
    // NOLINTNEXTLINE(hicpp-no-assembler)
    asm volatile("" : "+m,r"(val) : : "memory");
#endif
}
#endif


/**
 * An extremely fast random generator. Currently, this implements *RomuDuoJr*, developed by Mark
 * Overton. Source: http://www.romu-random.org/
 *
 * RomuDuoJr is extremely fast and provides reasonable good randomness. Not enough for large
 * jobs, but definitely good enough for a benchmarking framework.
 *
 *  * Estimated capacity: @f$ 2^{51} @f$ bytes
 *  * Register pressure: 4
 *  * State size: 128 bits
 *
 * This random generator is a drop-in replacement for the generators supplied by ``<random>``.
 * It is not cryptographically secure. It's intended purpose is to be very fast so that
 * benchmarks that make use of randomness are not distorted too much by the random generator.
 *
 * Rng also provides a few non-standard helpers, optimized for speed.
 */
class Rng final {
public:
    /**
     * @brief This RNG provides 64bit randomness.
     */
    using result_type = uint64_t;

    static constexpr uint64_t(min)();
    static constexpr uint64_t(max)();

    /**
     * As a safety precausion, we don't allow copying. Copying a PRNG would mean you would have
     * two random generators that produce the same sequence, which is generally not what one
     * wants. Instead create a new rng with the default constructor Rng(), which is
     * automatically seeded from `std::random_device`. If you really need a copy, use copy().
     */
    Rng(Rng const&) = delete;

    /**
     * Same as Rng(Rng const&), we don't allow assignment. If you need a new Rng create one with
     * the default constructor Rng().
     */
    Rng& operator=(Rng const&) = delete;

    // moving is ok
    Rng(Rng&&) noexcept            = default;
    Rng& operator=(Rng&&) noexcept = default;
    ~Rng() noexcept                = default;

    /**
     * @brief Creates a new Random generator with random seed.
     *
     * Instead of a default seed (as the random generators from the STD), this properly seeds
     * the random generator from `std::random_device`. It guarantees correct seeding. Note that
     * seeding can be relatively slow, depending on the source of randomness used. So it is best
     * to create a Rng once and use it for all your randomness purposes.
     */
    Rng();

    /*!
      Creates a new Rng that is seeded with a specific seed. Each Rng created from the same seed
      will produce the same randomness sequence. This can be useful for deterministic behavior.
      @verbatim embed:rst
      .. note::
         The random algorithm might change between nanobench releases. Whenever a faster and/or
      better random generator becomes available, I will switch the implementation.
      @endverbatim
      As per the Romu paper, this seeds the Rng with splitMix64 algorithm and performs 10
      initial rounds for further mixing up of the internal state.
      @param seed  The 64bit seed. All values are allowed, even 0.
     */
    explicit Rng(uint64_t seed) noexcept;
    Rng(uint64_t x, uint64_t y) noexcept;
    Rng(std::vector<uint64_t> const& data);

    /**
     * Creates a copy of the Rng, thus the copy provides exactly the same random sequence as the
     * original.
     */
    Rng copy() const noexcept;

    /**
     * @brief Produces a 64bit random value. This should be very fast, thus it is marked as
     * inline. In my benchmark, this is ~46 times faster than `std::default_random_engine` for
     * producing 64bit random values. It seems that the fastest std contender is
     * `std::mt19937_64`. Still, this RNG is 2-3 times as fast.
     *
     * @return uint64_t The next 64 bit random value.
     */
    inline uint64_t operator()() noexcept;

    // This is slightly biased. See

    /**
     * Generates a random number between 0 and range (excluding range).
     *
     * The algorithm only produces 32bit numbers, and is slightly biased. The effect is quite
     * small unless your range is close to the maximum value of an integer. It is possible to
     * correct the bias with rejection sampling (see
     * [here](https://lemire.me/blog/2016/06/30/fast-random-shuffling/), but this is most likely
     * irrelevant in practices for the purposes of this Rng.
     *
     * See Daniel Lemire's blog post [A fast alternative to the modulo
     * reduction](https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/)
     *
     * @param range Upper exclusive range. E.g a value of 3 will generate random numbers 0,
     * 1, 2.
     * @return uint32_t Generated random values in range [0, range(.
     */
    inline uint32_t bounded(uint32_t range) noexcept;

    // random double in range [0, 1(
    // see http://prng.di.unimi.it/

    /**
     * Provides a random uniform double value between 0 and 1. This uses the method described in
     * [Generating uniform doubles in the unit interval](http://prng.di.unimi.it/), and is
     * extremely fast.
     *
     * @return double Uniformly distributed double value in range [0,1(, excluding 1.
     */
    inline double uniform01() noexcept;

    /**
     * Shuffles all entries in the given container. Although this has a slight bias due to the
     * implementation of bounded(), this is preferable to `std::shuffle` because it is over 5
     * times faster. See Daniel Lemire's blog post [Fast random
     * shuffling](https://lemire.me/blog/2016/06/30/fast-random-shuffling/).
     *
     * @param container The whole container will be shuffled.
     */
    template <typename Container>
    void shuffle(Container& container) noexcept;

    /**
     * Extracts the full state of the generator, e.g. for serialization. For this RNG this is
     * just 2 values, but to stay API compatible with future implementations that potentially
     * use more state, we use a vector.
     *
     * @return Vector containing the full state:
     */
    std::vector<uint64_t> state() const;

private:
    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;

    uint64_t mX;
    uint64_t mY;
};

}  // namespace detail


/**
 * @brief Makes sure none of the given arguments are optimized away by the compiler.
 *
 * @tparam Arg Type of the argument that shouldn't be optimized away.
 * @param arg The input that we mark as being used, even though we don't do anything with it.
 */
template <typename Arg>
void doNotOptimizeAway(Arg&& arg) {
    detail::doNotOptimizeAway(std::forward<Arg>(arg));
}


#pragma endregion

}  // namespace zeroerr

#pragma once







#include <cstdint>
#include <exception>
#include <iostream>

#pragma region define macros

// This macro will be redefined in the log.h header, so the global context variable could be
// envolved only when we use log.h at the same time. If you didn't use log.h, this is still a
// header-only library.
#ifndef ZEROERR_G_CONTEXT_SCOPE
#define ZEROERR_G_CONTEXT_SCOPE(x)
#endif

#ifndef ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER
#define ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER(cond, level, ...)                    \
    do {                                                                          \
        if (cond) {                                                               \
            switch (zeroerr::assert_level::ZEROERR_CAT(level, _l)) {              \
                case zeroerr::assert_level::ZEROERR_WARN_l:                       \
                    std::cerr << zeroerr::FgYellow << "WARN" << zeroerr::Reset;   \
                    break;                                                        \
                case zeroerr::assert_level::ZEROERR_ERROR_l:                      \
                    std::cerr << zeroerr::FgRed << "ERROR" << zeroerr::Reset;     \
                    break;                                                        \
                case zeroerr::assert_level::ZEROERR_FATAL_l:                      \
                    std::cerr << zeroerr::FgMagenta << "FATAL" << zeroerr::Reset; \
                    break;                                                        \
            }                                                                     \
            std::cerr << zeroerr::format(__VA_ARGS__) << std::endl;               \
        }                                                                         \
    } while (0)
#endif

#ifdef ZEROERR_OS_WINDOWS
#define ZEROERR_PRINT_ASSERT(cond, level, pattern, ...)                                    \
    ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER(cond, level, " Assertion Failed:\n{msg}" pattern, \
                                         assertion_data.log(), __VA_ARGS__)
#else
#define ZEROERR_PRINT_ASSERT(cond, level, pattern, ...)                                    \
    ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER(cond, level, " Assertion Failed:\n{msg}" pattern, \
                                         assertion_data.log(), ##__VA_ARGS__)
#endif

#define ZEROERR_ASSERT(cond, level, throws, is_false, ...)                                       \
    ZEROERR_FUNC_SCOPE_BEGIN {                                                                   \
        zeroerr::assert_info info{zeroerr::assert_level::ZEROERR_CAT(level, _l),                 \
                                  zeroerr::assert_throw::throws, is_false};                      \
                                                                                                 \
        zeroerr::AssertionData assertion_data(__FILE__, __LINE__, #cond, info);                  \
        assertion_data.setResult(std::move(zeroerr::ExpressionDecomposer() << cond));            \
        zeroerr::detail::context_helper<                                                         \
            decltype(_ZEROERR_TEST_CONTEXT),                                                     \
            std::is_same<decltype(_ZEROERR_TEST_CONTEXT),                                        \
                         const bool>::value>::setContext(assertion_data, _ZEROERR_TEST_CONTEXT); \
        ZEROERR_PRINT_ASSERT(assertion_data.passed == false, level, __VA_ARGS__);                \
        if (false) debug_break();                                                                \
        assertion_data();                                                                        \
        ZEROERR_FUNC_SCOPE_RET(assertion_data.passed);                                           \
    }                                                                                            \
    ZEROERR_FUNC_SCOPE_END


#define ZEROERR_ASSERT_CMP(lhs, op, rhs, level, throws, is_false, ...)                           \
    ZEROERR_FUNC_SCOPE_BEGIN {                                                                   \
        zeroerr::assert_info info{zeroerr::assert_level::ZEROERR_CAT(level, _l),                 \
                                  zeroerr::assert_throw::throws, is_false};                      \
                                                                                                 \
        zeroerr::Printer print;                                                                           \
        print.isQuoted = false;                                                                  \
        zeroerr::AssertionData assertion_data(__FILE__, __LINE__, #lhs " " #op " " #rhs, info);  \
        assertion_data.setResult({(lhs)op(rhs), print(lhs, #op, rhs)});                          \
        zeroerr::detail::context_helper<                                                         \
            decltype(_ZEROERR_TEST_CONTEXT),                                                     \
            std::is_same<decltype(_ZEROERR_TEST_CONTEXT),                                        \
                         const bool>::value>::setContext(assertion_data, _ZEROERR_TEST_CONTEXT); \
        ZEROERR_PRINT_ASSERT(assertion_data.passed == false, level, __VA_ARGS__);                \
        if (false) debug_break();                                                                \
        assertion_data();                                                                        \
        ZEROERR_FUNC_SCOPE_RET(assertion_data.passed);                                           \
    }                                                                                            \
    ZEROERR_FUNC_SCOPE_END


#ifdef ZEROERR_NO_ASSERT

#define CHECK(cond, ...)
#define CHECK_NOT(cond, ...)
#define REQUIRE(cond, ...)
#define REQUIRE_NOT(cond, ...)
#define ASSERT(cond, ...)
#define ASSERT_NOT(cond, ...)

#define CHECK_EQ(lhs, rhs, ...)
#define CHECK_NE(lhs, rhs, ...)
#define CHECK_LT(lhs, rhs, ...)
#define CHECK_LE(lhs, rhs, ...)
#define CHECK_GT(lhs, rhs, ...)
#define CHECK_GE(lhs, rhs, ...)

#define REQUIRE_EQ(lhs, rhs, ...)
#define REQUIRE_NE(lhs, rhs, ...)
#define REQUIRE_LT(lhs, rhs, ...)
#define REQUIRE_LE(lhs, rhs, ...)
#define REQUIRE_GT(lhs, rhs, ...)
#define REQUIRE_GE(lhs, rhs, ...)

#define ASSERT_EQ(lhs, rhs, ...)
#define ASSERT_NE(lhs, rhs, ...)
#define ASSERT_LT(lhs, rhs, ...)
#define ASSERT_LE(lhs, rhs, ...)
#define ASSERT_GT(lhs, rhs, ...)
#define ASSERT_GE(lhs, rhs, ...)

#else

#define CHECK(cond, ...)       ZEROERR_ASSERT(cond, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_NOT(cond, ...)   ZEROERR_ASSERT(cond, ZEROERR_WARN, no_throw, true, __VA_ARGS__)
#define REQUIRE(cond, ...)     ZEROERR_ASSERT(cond, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_NOT(cond, ...) ZEROERR_ASSERT(cond, ZEROERR_ERROR, throws, true, __VA_ARGS__)
#define ASSERT(cond, ...)      ZEROERR_ASSERT(cond, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_NOT(cond, ...)  ZEROERR_ASSERT(cond, ZEROERR_FATAL, throws, true, __VA_ARGS__)

#define CHECK_EQ(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, ==, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_NE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, !=, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_LT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_LE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <=, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_GT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)
#define CHECK_GE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >=, rhs, ZEROERR_WARN, no_throw, false, __VA_ARGS__)

#define REQUIRE_EQ(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, ==, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_NE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, !=, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_LT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_LE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <=, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_GT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)
#define REQUIRE_GE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >=, rhs, ZEROERR_ERROR, throws, false, __VA_ARGS__)

#define ASSERT_EQ(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, ==, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_NE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, !=, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_LT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_LE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, <=, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_GT(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)
#define ASSERT_GE(lhs, rhs, ...) \
    ZEROERR_ASSERT_CMP(lhs, >=, rhs, ZEROERR_FATAL, throws, false, __VA_ARGS__)

#endif

#pragma endregion


// This symbol must be in the global namespace or anonymous namespace
// used for checking the assert is inside testing or not
namespace {
constexpr bool _ZEROERR_TEST_CONTEXT = false;
}  // namespace


namespace zeroerr {

enum class assert_level : uint8_t { ZEROERR_WARN_l, ZEROERR_ERROR_l, ZEROERR_FATAL_l };
enum class assert_throw : uint8_t { no_throw, throws, throws_as };
enum class assert_cmp : uint8_t { eq, ne, gt, ge, lt, le };

// This is a one-byte assert info struct, which is used to collect the meta info of an assertion
struct assert_info {
    assert_level level      : 2;
    assert_throw throw_type : 2;
    bool         is_false   : 1;
};


#pragma region handle message


struct AssertionData : std::exception {
    const char* file;
    unsigned    line;
    assert_info info;
    bool        passed;
    std::string message;
    std::string cond;

    AssertionData(const char* file, unsigned line, const char* cond, assert_info info)
        : file(file), line(line), cond(cond), info(info) {}

    void setResult(ExprResult&& result) {
        ExprResult r(std::move(result));
        if (info.is_false)
            passed = !r.res;
        else
            passed = r.res;
        message = r.decomp;
    }

    std::string log() {
        std::stringstream ss;
        ss << "    " << cond << "  expands to  " << message << std::endl;
        ss << Dim << "(" << file << ":" << line << ")" << Reset << std::endl;
        return ss.str();
    }


    // throw the exception
    void operator()() {
        if (passed) return;
        if (shouldThrow()) throw *this;
    }

    bool shouldThrow() { return info.throw_type == assert_throw::throws; }
};

namespace detail {
// This struct is used for handle constexpr if in C++11
// https://stackoverflow.com/questions/43587405/constexpr-if-alternative
template <typename T, bool>
struct context_helper;

template <typename T>
struct context_helper<T, true> {
    static void setContext(AssertionData& data, T) {
        if (data.passed) return;
    }
};

template <typename T>
struct context_helper<T, false> {
    static void setContext(AssertionData& data, T ctx) {
        if (data.passed) {
            ctx->passed_as++;
            return;
        }
        switch (data.info.level) {
            case assert_level::ZEROERR_FATAL_l:
            case assert_level::ZEROERR_ERROR_l: ctx->failed_as++; break;
            case assert_level::ZEROERR_WARN_l: ctx->warning_as++; break;
        }
    }
};
}  // namespace detail

#pragma endregion


}  // namespace zeroerr
#pragma once





#include <iostream>
#include <tuple>  // for std::get and std::tie

#ifndef ZEROERR_DISABLE_DBG_MARCO
#define dbg(...) zeroerr::DebugExpr(__FILE__, __LINE__, __func__, #__VA_ARGS__, __VA_ARGS__)
#else
#define dbg(...) (__VA_ARGS__)
#endif

namespace zeroerr {

template <class T1, class... T>
struct last {
    using type = typename last<T...>::type;
};

template <class T1>
struct last<T1> {
    using type = T1;
};

template <typename... Args>
auto get_last(Args&&... args) -> typename last<Args...>::type {
    return std::get<sizeof...(Args) - 1>(std::tie(args...));
}

template <typename... T>
auto DebugExpr(const char* file, unsigned line, const char* func, const char* exprs, T... t) ->
    typename last<T...>::type {
    std::string fileName(file);
    auto        p = fileName.find_last_of('/');
    if (p != std::string::npos) fileName = fileName.substr(p + 1);

    std::cerr << Dim << "[" << fileName << ":" << line << " " << func << "] " << Reset;
    std::cerr << FgCyan << exprs << Reset << " = ";
    Printer print(std::cerr);
    print.line_break = "";
    print(t...);
    std::cerr << " (" << FgGreen;
    std::string typenames[] = {print.type(t)...};
    for (unsigned i = 0; i < sizeof...(T); ++i) {
        if (i != 0) std::cerr << ", ";
        std::cerr << typenames[i];
    }
    std::cerr << Reset << ")" << std::endl;
    return get_last(t...);
}


}  // namespace zeroerr

#pragma once

#include <string>
#include <sstream>


namespace zeroerr
{

template <typename... T>
std::string format(const char* fmt, T... args) {
    std::stringstream ss;
    bool parse_name = false;
    Printer print; print.isQuoted = false;
    std::string str_args[] = {print(args)...};
    int j = 0;
    for (const char* i = fmt; *i != '\0'; i++) {
        switch (*i)
        {
        case '{': 
            parse_name = true; 
            break;
        case '}': 
            parse_name = false; 
            ss << str_args[j++];
            break;
        default:
            if (!parse_name) ss << *i;
            break;
        }
    }
    return ss.str();
}

} // namespace zeroerr

#pragma once




#include <chrono>
#include <cstdlib>
#include <deque>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <unordered_set>
#include <vector>

extern const char* ZEROERR_LOG_CATEGORY;

namespace std {
class mutex;
}

namespace zeroerr {

#pragma region log macros


#define ZEROERR_INFO(...)  ZEROERR_EXPAND(ZEROERR_INFO_(__VA_ARGS__))
#define ZEROERR_LOG(...)   ZEROERR_EXPAND(ZEROERR_LOG_(LOG_l, __VA_ARGS__))
#define ZEROERR_WARN(...)  ZEROERR_EXPAND(ZEROERR_LOG_(WARN_l, __VA_ARGS__))
#define ZEROERR_ERROR(...) ZEROERR_EXPAND(ZEROERR_LOG_(ERROR_l, __VA_ARGS__))
#define ZEROERR_FATAL(...) ZEROERR_EXPAND(ZEROERR_LOG_(FATAL_l, __VA_ARGS__))

#ifdef ZEROERR_USE_SHORT_LOG_MACRO

#ifdef INFO
#undef INFO
#endif

#ifdef LOG
#undef LOG
#endif

#ifdef WARN
#undef WARN
#endif

#ifdef ERROR
#undef ERROR
#endif

#ifdef FATAL
#undef FATAL
#endif

#define INFO(...)  ZEROERR_INFO(__VA_ARGS__)
#define LOG(...)   ZEROERR_LOG(__VA_ARGS__)
#define WARN(...)  ZEROERR_WARN(__VA_ARGS__)
#define ERROR(...) ZEROERR_ERROR(__VA_ARGS__)
#define FATAL(...) ZEROERR_FATAL(__VA_ARGS__)

#endif

#define ZEROERR_LOG_IF(condition, ACTION, ...) \
    do {                                       \
        if (condition) ACTION(__VA_ARGS__);    \
    } while (0)


#define INFO_IF(cond, ...)  ZEROERR_LOG_IF(cond, ZEROERR_INFO, __VA_ARGS__)
#define LOG_IF(cond, ...)   ZEROERR_LOG_IF(cond, ZEROERR_LOG, __VA_ARGS__)
#define WARN_IF(cond, ...)  ZEROERR_LOG_IF(cond, ZEROERR_WARN, __VA_ARGS__)
#define ERROR_IF(cond, ...) ZEROERR_LOG_IF(cond, ZEROERR_ERROR, __VA_ARGS__)
#define FATAL_IF(cond, ...) ZEROERR_LOG_IF(cond, ZEROERR_FATAL, __VA_ARGS__)


#define ZEROERR_LOG_EVERY_(n, ACTION, ...) \
    do {                                   \
        unsigned counter = 0;              \
        if (counter == 0) {                \
            counter = n;                   \
            ACTION(__VA_ARGS__);           \
        }                                  \
        --counter;                         \
    } while (0)


#define INFO_EVERY_(cond, ...)  ZEROERR_LOG_EVERY_(cond, ZEROERR_INFO, __VA_ARGS__)
#define LOG_EVERY_(cond, ...)   ZEROERR_LOG_EVERY_(cond, ZEROERR_LOG, __VA_ARGS__)
#define WARN_EVERY_(cond, ...)  ZEROERR_LOG_EVERY_(cond, ZEROERR_WARN, __VA_ARGS__)
#define ERROR_EVERY_(cond, ...) ZEROERR_LOG_EVERY_(cond, ZEROERR_ERROR, __VA_ARGS__)
#define FATAL_EVERY_(cond, ...) ZEROERR_LOG_EVERY_(cond, ZEROERR_FATAL, __VA_ARGS__)


#define ZEROERR_LOG_IF_EVERY_(n, cond, ACTION, ...) \
    do {                                            \
        unsigned counter = 0;                       \
        if (counter == 0 && (cond)) {               \
            counter = n;                            \
            ACTION(__VA_ARGS__);                    \
        }                                           \
        --counter;                                  \
    } while (0)

#define INFO_IF_EVERY_(n, cond, ...)  ZEROERR_LOG_IF_EVERY_(n, cond, ZEROERR_INFO, __VA_ARGS__)
#define LOG_IF_EVERY_(n, cond, ...)   ZEROERR_LOG_IF_EVERY_(n, cond, ZEROERR_LOG, __VA_ARGS__)
#define WARN_IF_EVERY_(n, cond, ...)  ZEROERR_LOG_IF_EVERY_(n, cond, ZEROERR_WARN, __VA_ARGS__)
#define ERROR_IF_EVERY_(n, cond, ...) ZEROERR_LOG_IF_EVERY_(n, cond, ZEROERR_ERROR, __VA_ARGS__)
#define FATAL_IF_EVERY_(n, cond, ...) ZEROERR_LOG_IF_EVERY_(n, cond, ZEROERR_FATAL, __VA_ARGS__)

#define ZEROERR_LOG_FIRST(cond, ACTION, ...) \
    do {                                     \
        bool first = true;                   \
        if (first && (cond)) {               \
            first = false;                   \
            ACTION(__VA_ARGS__);             \
        }                                    \
    } while (0)

#define INFO_FIRST(cond, ...)  ZEROERR_LOG_FIRST(cond, ZEROERR_INFO, __VA_ARGS__)
#define LOG_FIRST(cond, ...)   ZEROERR_LOG_FIRST(cond, ZEROERR_LOG, __VA_ARGS__)
#define WARN_FIRST(cond, ...)  ZEROERR_LOG_FIRST(cond, ZEROERR_WARN, __VA_ARGS__)
#define ERROR_FIRST(cond, ...) ZEROERR_LOG_FIRST(cond, ZEROERR_ERROR, __VA_ARGS__)
#define FATAL_FIRST(cond, ...) ZEROERR_LOG_FIRST(cond, ZEROERR_FATAL, __VA_ARGS__)

#define ZEROERR_LOG_FIRST_(n, cond, ACTION, ...) \
    do {                                         \
        unsigned counter = n;                    \
        if (n-- && (cond)) {                     \
            ACTION(__VA_ARGS__);                 \
        }                                        \
    } while (0)

#define INFO_FIRST_(n, cond, ...)  ZEROERR_LOG_FIRST_(n, cond, ZEROERR_INFO, __VA_ARGS__)
#define LOG_FIRST_(n, cond, ...)   ZEROERR_LOG_FIRST_(n, cond, ZEROERR_LOG, __VA_ARGS__)
#define WARN_FIRST_(n, cond, ...)  ZEROERR_LOG_FIRST_(n, cond, ZEROERR_WARN, __VA_ARGS__)
#define ERROR_FIRST_(n, cond, ...) ZEROERR_LOG_FIRST_(n, cond, ZEROERR_ERROR, __VA_ARGS__)
#define FATAL_FIRST_(n, cond, ...) ZEROERR_LOG_FIRST_(n, cond, ZEROERR_FATAL, __VA_ARGS__)

#ifdef _DEBUG
#define DLOG(ACTION, ...) ACTION(__VA_ARGS__)
#else
#define DLOG(ACTION, ...)
#endif


#define ZEROERR_LOG_(severity, message, ...)                                                  \
    do {                                                                                      \
        ZEROERR_G_CONTEXT_SCOPE(true);                                                        \
        auto                    msg = zeroerr::LogStream::getDefault().push(__VA_ARGS__);     \
        static zeroerr::LogInfo log_info{__FILE__, message,  ZEROERR_LOG_CATEGORY,            \
                                         __LINE__, msg.size, zeroerr::LogSeverity::severity}; \
        msg.log->info = &log_info;                                                            \
        if (zeroerr::LogStream::getDefault().flush_mode ==                                    \
            zeroerr::LogStream::FlushMode::FLUSH_AT_ONCE)                                     \
            zeroerr::LogStream::getDefault().flush();                                         \
    } while (0)

#define ZEROERR_INFO_(...) \
    ZEROERR_INFO_IMPL(ZEROERR_NAMEGEN(_capture_), ZEROERR_NAMEGEN(_capture_), __VA_ARGS__)

#define ZEROERR_INFO_IMPL(mb_name, v_name, ...)                                \
    auto v_name = zeroerr::MakeContextScope([&](std::ostream& _capture_name) { \
        Printer print(_capture_name);                                          \
        print.isQuoted = false;                                                \
        print(__VA_ARGS__);                                                    \
    })

#ifdef ZEROERR_G_CONTEXT_SCOPE
#undef ZEROERR_G_CONTEXT_SCOPE
#endif

#define ZEROERR_G_CONTEXT_SCOPE(x)                                 \
    if (x) {                                                       \
        for (auto* i : zeroerr::_ZEROERR_G_CONTEXT_SCOPE_VECTOR) { \
            i->str(std::cerr);                                     \
        }                                                          \
    }

#ifdef ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER
#undef ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER
#endif

#define ZEROERR_PRINT_ASSERT_DEFAULT_PRINTER(cond, level, ...) \
    ZEROERR_LOG_IF(cond, level, __VA_ARGS__)

#pragma endregion

namespace detail {

template <typename T, unsigned... I>
std::string gen_str(const char* msg, const T& args, seq<I...>) {
    return format(msg, std::get<I>(args)...);
}

template <typename T>
std::string gen_str(const char* msg, const T& args, seq<>) {
    return msg;
}

}  // namespace detail


enum LogSeverity {
    INFO_l,  // it will not write to file if no other log related
    LOG_l,
    WARN_l,
    ERROR_l,
    FATAL_l,  // it will contain a stack trace
};

struct LogTime {};

struct LogInfo {
    const char* filename;
    const char* message;
    const char* category;
    unsigned    line;
    unsigned    size;
    LogSeverity severity;
};

typedef void (*LogCustomCallback)(LogInfo);

extern void setLogLevel(LogSeverity level);
extern void setLogCategory(const char* categories);

struct LogMessage {
    LogMessage() { time = std::chrono::system_clock::now(); }

    virtual std::string str(bool colorful = true) = 0;

    // meta data of this log message
    LogInfo* info;

    // recorded wall time
    std::chrono::system_clock::time_point time;
};

#define zeroerr_color(x) (colorful ? x : "")

template <typename... T>
struct LogMessageImpl : LogMessage {
    LogMessageImpl(T... args) : LogMessage(), args(args...) {}

    std::string str(bool colorful = true) override {
        std::stringstream ss;
        std::time_t       t  = std::chrono::system_clock::to_time_t(time);
        std::tm           tm = *std::localtime(&t);

        ss << zeroerr_color(Dim) << '[' << zeroerr_color(Reset);
        switch (info->severity) {
            case INFO_l: ss << "INFO "; break;
            case LOG_l: ss << zeroerr_color(FgGreen) << "LOG  " << zeroerr_color(Reset); break;
            case WARN_l: ss << zeroerr_color(FgYellow) << "WARN " << zeroerr_color(Reset); break;
            case ERROR_l: ss << zeroerr_color(FgRed) << "ERROR" << zeroerr_color(Reset); break;
            case FATAL_l: ss << zeroerr_color(FgMagenta) << "FATAL" << zeroerr_color(Reset); break;
        }
        ss << " " << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");

        std::string fileName(info->filename);

        auto p = fileName.find_last_of('/');
        if (p != std::string::npos) fileName = fileName.substr(p + 1);
        auto q = fileName.find_last_of('\\');
        if (q != std::string::npos) fileName = fileName.substr(q + 1);

        ss << " " << fileName << ":" << info->line;
        ss << zeroerr_color(Dim) << ']' << zeroerr_color(Reset) << "  "
           << gen_str(info->message, args, detail::gen_seq<sizeof...(T)>{});
        return ss.str();
    }

    std::tuple<T...> args;
};


constexpr size_t LogStreamMaxSize = 1024 * 1024;

struct DataBlock {
    char       data[LogStreamMaxSize];
    size_t     size = 0;
    DataBlock* next = nullptr;
};

class Logger {
public:
    virtual void flush(DataBlock*) = 0;
};

class LogStream {
public:
    LogStream();
    virtual ~LogStream();

    struct PushResult {
        LogMessage* log;
        unsigned    size;
    };

    enum FlushMode { FLUSH_AT_ONCE, FLUSH_WHEN_FULL, FLUSH_MANULLY };

    template <typename... T>
    PushResult push(T&&... args) {
        unsigned    size = sizeof(LogMessageImpl<T...>);
        void*       p    = alloc_block(size);
        LogMessage* msg  = new (p) LogMessageImpl<T...>(std::forward<T>(args)...);
        return {msg, size};
    }

    void flush();

    void setBinFileLogger(std::string name);
    void setFileLogger(std::string name);
    void setStdoutLogger();
    void setStderrLogger();

    static LogStream& getDefault();
    FlushMode         flush_mode = FLUSH_AT_ONCE;

private:
    DataBlock *first, *last;
    Logger*    logger = nullptr;
#ifndef ZEROERR_NO_THREAD_SAFE
    std::mutex* mutex;
#endif
    void* alloc_block(unsigned size);
};


/**
 * @brief ContextScope is a helper class created in each basic block where you use INFO().
 * The context scope can has lazy evaluated function F(std::ostream&) that is called when the
 * assertation is failed
 */
class IContextScope {
public:
    virtual void str(std::ostream& os) const = 0;
};

extern thread_local std::vector<IContextScope*> _ZEROERR_G_CONTEXT_SCOPE_VECTOR;

template <typename F>
class ContextScope : public IContextScope {
public:
    ContextScope(F f) : f_(f) { _ZEROERR_G_CONTEXT_SCOPE_VECTOR.push_back(this); }
    ~ContextScope() { _ZEROERR_G_CONTEXT_SCOPE_VECTOR.pop_back(); }

    virtual void str(std::ostream& os) const override { return f_(os); }

protected:
    F f_;
};

template <typename F>
ContextScope<F> MakeContextScope(const F& f) {
    return ContextScope<F>(f);
}


}  // namespace zeroerr

#pragma once





#include <ostream>
#include <string>
#include <vector>

namespace zeroerr {


struct Card {
    Card(std::string title) : title(title) {}

    std::string title;
    unsigned    width, height;

    void show(std::ostream& os, std::string str);
};

class Table {
public:
    Table() {}
    Table(std::string title) : title(title) {}
    Table(unsigned width, unsigned height) : width(width), height(height) {}
    Table(std::string title, unsigned width, unsigned height)
        : title(title), width(width), height(height) {}
    ~Table() {}

    Table& csv(std::string path);
    Table& json(std::string path);

    struct Style {
        Style() {}
        Style(std::initializer_list<std::string> args) : m_args(args) {}
        std::vector<std::string> m_args;

        operator bool() const { return !m_args.empty(); }
    };
    static void  registerStyle(std::string name, Style style);
    static Style getStyle(std::string name);

    struct Config {
        bool show_tb_border;
        bool show_lr_border;
        bool show_header_split;
        bool show_col_split;
        bool show_row_split;
        bool show_footer_split;
        Config()
            : show_tb_border(true),
              show_lr_border(true),
              show_header_split(true),
              show_col_split(true),
              show_row_split(true),
              show_footer_split(true) {}
    };

    std::string str(Config config = Config(), Style style = Table::getStyle("square_double_head"));

    void set_header(std::vector<std::string> _header) { header = _header; }
    void add_row(std::initializer_list<std::string> _row) { cells.push_back(_row); }

    template <typename T, typename... Args>
    void push_back(std::vector<std::string>& row, T&& t, Args&&... args) {
        _push_back(rank<2>{}, row, std::forward<T>(t));
        push_back(row, std::forward<Args>(args)...);
    }

    template <typename T>
    void push_back(std::vector<std::string>& row, T&& t) {
        _push_back(rank<2>{}, row, std::forward<T>(t));
    }


    ZEROERR_ENABLE_IF(!ZEROERR_IS_CONTAINER)
    _push_back(rank<0>, std::vector<std::string>& row, T&& t) {
        Printer print;
        print.isCompact  = true;
        print.isQuoted   = false;
        print.line_break = "";
        print(std::forward<T>(t));
        row.push_back(print.str());
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_STRING)
    _push_back(rank<2>, std::vector<std::string>& row, T t) {
        row.push_back(std::forward<std::string>(t));
    }

    ZEROERR_ENABLE_IF(ZEROERR_IS_CONTAINER)
    _push_back(rank<1>, std::vector<std::string>& row, const T& t) {
        for (auto& ele : t) {
            Printer print;
            print.isCompact  = true;
            print.isQuoted   = false;
            print.line_break = "";
            print(ele);
            row.push_back(print.str());
        }
    }

    template <typename... Args>
    void add_row(Args&&... args) {
        std::vector<std::string> row;
        push_back(row, std::forward<Args>(args)...);
        cells.push_back(row);
    }

    template <typename T, typename... Args>
    void add_rows(T&& t, Args&&... args) {
        add_row(std::forward<T>(t));
        add_rows(std::forward<Args>(args)...);
    }

    template <typename T>
    void add_rows(T&& t) {
        add_row(std::forward<T>(t));
    }

protected:
    std::string title;
    unsigned    width = 0, height = 0;  // auto-calculated


    std::vector<unsigned>                 col_width;
    std::vector<std::string>              header, footer;
    std::vector<std::vector<std::string>> cells;
};


}  // namespace  zeroerr

#pragma once

namespace zeroerr {}  // namespace zeroerr

#pragma once



#include <cstring>
#include <functional>
#include <string>
#include <vector>

#pragma region unittest

#define ZEROERR_CREATE_TEST_FUNC(function, name)                     \
    static void                     function(zeroerr::TestContext*); \
    static zeroerr::detail::regTest ZEROERR_NAMEGEN(_zeroerr_reg)(   \
        {name, __FILE__, __LINE__, function});                       \
    static void function(zeroerr::TestContext* _ZEROERR_TEST_CONTEXT)

#define TEST_CASE(name) ZEROERR_CREATE_TEST_FUNC(ZEROERR_NAMEGEN(_zeroerr_testcase), name)

#define SUB_CASE(name)                                                   \
    zeroerr::SubCaseReg(name, __FILE__, __LINE__, _ZEROERR_TEST_CONTEXT) \
        << [](zeroerr::TestContext * _ZEROERR_TEST_CONTEXT)

#define ZEROERR_CREATE_TEST_CLASS(fixture, classname, funcname, name)                        \
    class classname : public fixture {                                                       \
    public:                                                                                  \
        void funcname(zeroerr::TestContext*);                                                \
    };                                                                                       \
    static void ZEROERR_CAT(call_, funcname)(zeroerr::TestContext * _ZEROERR_TEST_CONTEXT) { \
        classname instance;                                                                  \
        instance.funcname(_ZEROERR_TEST_CONTEXT);                                            \
    }                                                                                        \
    static zeroerr::detail::regTest ZEROERR_NAMEGEN(_zeroerr_reg)(                           \
        {name, __FILE__, __LINE__, ZEROERR_CAT(call_, funcname)});                           \
    inline void classname::funcname(zeroerr::TestContext* _ZEROERR_TEST_CONTEXT)

#define TEST_CASE_FIXTURE(fixture, name)                                \
    ZEROERR_CREATE_TEST_CLASS(fixture, ZEROERR_NAMEGEN(_zeroerr_class), \
                              ZEROERR_NAMEGEN(_zeroerr_test_method), name)


#define ZEROERR_HAVE_SAME_OUTPUT _ZEROERR_TEST_CONTEXT->save_output();


namespace zeroerr {

class TestContext {
public:
    unsigned passed = 0, warning = 0, failed = 0, skipped = 0;
    unsigned passed_as = 0, warning_as = 0, failed_as = 0, skipped_as = 0;

    int  add(TestContext&& local);
    void save_output();
};

class IReporter;
class UnitTest {
public:
    UnitTest&   parseArgs(int argc, char** argv);
    int         run();
    bool        silent   = false;
    IReporter*  reporter = nullptr;
    std::string correct_output_path;
};

struct TestCase {
    std::string name;
    std::string file;
    unsigned    line;
    void (*func)(TestContext*);
    bool operator<(const TestCase& rhs) const;
};

struct SubCaseReg {
    SubCaseReg(std::string name, std::string file, unsigned line, TestContext* context);
    ~SubCaseReg() {}
    TestContext* context;

    void operator<<(std::function<void(TestContext*)> op);
};


template <typename T>
struct TestedObjects {
    void           add(T&& obj) { objects.push_back(std::forward<T>(obj)); }
    std::vector<T> objects;
};


#pragma endregion

#pragma region reporter

class IReporter {
public:
    virtual std::string getName() const = 0;

    virtual void reportQuery() = 0;

    virtual void reportResult(const TestContext& tc) = 0;

    // There are a list of events
    virtual void testStart() = 0;
    virtual void testEnd()   = 0;

    virtual void testCaseStart(const TestCase& tc) = 0;
    virtual void testCaseEnd(const TestCase& tc)   = 0;
};


namespace detail {

struct regTest {
    explicit regTest(const TestCase& tc);
};

struct regReporter {
    explicit regReporter(IReporter*);
};
}  // namespace detail


#pragma endregion


}  // namespace zeroerr

#ifdef ZEROERR_IMPLEMENTATION



#include <cstring>
#include <iostream>
#include <random>
#include <stdexcept>

#ifdef ZEROERR_PERF
#include <linux/perf_event.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <map>
#endif

namespace zeroerr {

#ifdef _WIN32
namespace detail {
struct WindowsPerformanceCounter {};
}  // namespace detail
#endif


#ifdef ZEROERR_PERF
namespace detail {
struct LinuxPerformanceCounter {
    inline void beginMeasure() {
        if (mHasError) return;

        mHasError = -1 == ioctl(mFd, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);
        if (mHasError) return;

        mHasError = -1 == ioctl(mFd, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
    }
    inline void endMeasure() {
        if (mHasError) return;

        mHasError = (-1 == ioctl(mFd, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP));
        if (mHasError) return;

        auto const numBytes = sizeof(uint64_t) * mCounters.size();
        auto       ret      = read(mFd, mCounters.data(), numBytes);
        mHasError           = ret != static_cast<ssize_t>(numBytes);
    }


    // rounded integer division
    template <typename T>
    static inline T divRounded(T a, T divisor) {
        return (a + divisor / 2) / divisor;
    }

    static inline uint32_t mix(uint32_t x) noexcept {
        x ^= x << 13;
        x ^= x >> 17;
        x ^= x << 5;
        return x;
    }

    template <typename Op>
    void calibrate(Op&& op) {
        // clear current calibration data,
        for (auto& v : mCalibratedOverhead) {
            v = UINT64_C(0);
        }

        // create new calibration data
        auto newCalibration = mCalibratedOverhead;
        for (auto& v : newCalibration) {
            v = std::numeric_limits<uint64_t>::max();
        }
        for (size_t iter = 0; iter < 100; ++iter) {
            beginMeasure();
            op();
            endMeasure();
            if (mHasError) return;

            for (size_t i = 0; i < newCalibration.size(); ++i) {
                auto diff = mCounters[i];
                if (newCalibration[i] > diff) {
                    newCalibration[i] = diff;
                }
            }
        }

        mCalibratedOverhead = std::move(newCalibration);

        {
            // calibrate loop overhead. For branches & instructions this makes sense, not so much
            // for everything else like cycles. marsaglia's xorshift: mov, sal/shr, xor. Times 3.
            // This has the nice property that the compiler doesn't seem to be able to optimize
            // multiple calls any further. see https://godbolt.org/z/49RVQ5
            uint64_t const numIters = 100000U + (std::random_device{}() & 3);
            uint64_t       n        = numIters;
            uint32_t       x        = 1234567;

            beginMeasure();
            while (n-- > 0) {
                x = mix(x);
            }
            endMeasure();
            detail::doNotOptimizeAway(x);
            auto measure1 = mCounters;

            n = numIters;
            beginMeasure();
            while (n-- > 0) {
                // we now run *twice* so we can easily calculate the overhead
                x = mix(x);
                x = mix(x);
            }
            endMeasure();
            detail::doNotOptimizeAway(x);
            auto measure2 = mCounters;

            for (size_t i = 0; i < mCounters.size(); ++i) {
                // factor 2 because we have two instructions per loop
                auto m1 =
                    measure1[i] > mCalibratedOverhead[i] ? measure1[i] - mCalibratedOverhead[i] : 0;
                auto m2 =
                    measure2[i] > mCalibratedOverhead[i] ? measure2[i] - mCalibratedOverhead[i] : 0;
                auto overhead = m1 * 2 > m2 ? m1 * 2 - m2 : 0;

                mLoopOverhead[i] = divRounded(overhead, numIters);
            }
        }
    }


    struct Target {
        uint64_t* targetValue;
        bool      correctMeasuringOverhead;
        bool      correctLoopOverhead;
    };

    std::map<uint64_t, Target> mIdToTarget{};

    // start with minimum size of 3 for read_format
    std::vector<uint64_t> mCounters{3};
    std::vector<uint64_t> mCalibratedOverhead{3};
    std::vector<uint64_t> mLoopOverhead{3};

    uint64_t mTimeEnabledNanos = 0;
    uint64_t mTimeRunningNanos = 0;

    int  mFd       = -1;
    bool mHasError = false;

    ~LinuxPerformanceCounter() {
        if (mFd != -1) close(mFd);
    }

    bool monitor(perf_sw_ids swId, Target target) {
        return monitor(PERF_TYPE_SOFTWARE, swId, target);
    }

    bool monitor(perf_hw_id hwId, Target target) {
        return monitor(PERF_TYPE_HARDWARE, hwId, target);
    }

    bool monitor(uint32_t type, uint64_t eventid, Target target) {
        *target.targetValue = (std::numeric_limits<uint64_t>::max)();
        if (mHasError) return false;

        auto pea = perf_event_attr();
        std::memset(&pea, 0, sizeof(perf_event_attr));
        pea.type           = type;
        pea.size           = sizeof(perf_event_attr);
        pea.config         = eventid;
        pea.disabled       = 1;  // start counter as disabled
        pea.exclude_kernel = 1;
        pea.exclude_hv     = 1;

        pea.read_format = PERF_FORMAT_GROUP | PERF_FORMAT_ID | PERF_FORMAT_TOTAL_TIME_ENABLED |
                          PERF_FORMAT_TOTAL_TIME_RUNNING;

        const int pid = 0;         // the current process
        const int cpu = -1;        // all CPUs
#if defined(PERF_FLAG_FD_CLOEXEC)  // since Linux 3.14
        const unsigned long flags = PERF_FLAG_FD_CLOEXEC;
#else
        const unsigned long flags = 0;
#endif

        auto fd = static_cast<int>(syscall(__NR_perf_event_open, &pea, pid, cpu, mFd, flags));
        if (-1 == fd) return false;
        // first call: set to fd, and use this from now on
        if (-1 == mFd) mFd = fd;

        uint64_t id = 0;
        if (-1 == ioctl(fd, PERF_EVENT_IOC_ID, &id)) return false;

        // insert into map, rely on the fact that map's references are constant.
        mIdToTarget.emplace(id, target);

        // prepare readformat with the correct size (after the insert)
        auto size = 3 + 2 * mIdToTarget.size();
        mCounters.resize(size);
        mCalibratedOverhead.resize(size);
        mLoopOverhead.resize(size);

        return true;
    }

    void updateResults(uint64_t numIters) {
        // clear old data
        for (auto& id_value : mIdToTarget) {
            *id_value.second.targetValue = UINT64_C(0);
        }

        if (mHasError) return;

        mTimeEnabledNanos = mCounters[1] - mCalibratedOverhead[1];
        mTimeRunningNanos = mCounters[2] - mCalibratedOverhead[2];

        for (uint64_t i = 0; i < mCounters[0]; ++i) {
            auto idx = static_cast<size_t>(3 + i * 2 + 0);
            auto id  = mCounters[idx + 1U];

            auto it = mIdToTarget.find(id);
            if (it != mIdToTarget.end()) {
                auto& tgt        = it->second;
                *tgt.targetValue = mCounters[idx];
                if (tgt.correctMeasuringOverhead) {
                    if (*tgt.targetValue >= mCalibratedOverhead[idx]) {
                        *tgt.targetValue -= mCalibratedOverhead[idx];
                    } else {
                        *tgt.targetValue = 0U;
                    }
                }
                if (tgt.correctLoopOverhead) {
                    auto correctionVal = mLoopOverhead[idx] * numIters;
                    if (*tgt.targetValue >= correctionVal) {
                        *tgt.targetValue -= correctionVal;
                    } else {
                        *tgt.targetValue = 0U;
                    }
                }
            }
        }
    }
};
}  // namespace detail
#endif

#pragma region PerformanceCounter

PerformanceCounter::PerformanceCounter() {
    _has.timeElapsed() = true; // this should be always available
#ifdef ZEROERR_PERF
    _perf        = new detail::LinuxPerformanceCounter();
    using Target = detail::LinuxPerformanceCounter::Target;
    
    _has.pageFaults() =
        _perf->monitor(PERF_COUNT_SW_PAGE_FAULTS, Target{&_val.pageFaults(), true, false});
    _has.cpuCycles() =
        _perf->monitor(PERF_COUNT_HW_CPU_CYCLES, Target{&_val.cpuCycles(), true, false});
    _has.contextSwitches() = _perf->monitor(PERF_COUNT_SW_CONTEXT_SWITCHES,
                                            Target{&_val.contextSwitches(), true, false});
    _has.instructions() =
        _perf->monitor(PERF_COUNT_HW_INSTRUCTIONS, Target{&_val.instructions(), true, true});
    _has.branchInstructions() = _perf->monitor(PERF_COUNT_HW_BRANCH_INSTRUCTIONS,
                                               Target{&_val.branchInstructions(), true, false});
    _has.branchMisses() =
        _perf->monitor(PERF_COUNT_HW_BRANCH_MISSES, Target{&_val.branchMisses(), true, false});

    _perf->calibrate([] {
        auto before = Clock::now();
        auto after  = Clock::now();
        (void)before;
        (void)after;
    });

    if (_perf->mHasError) {
        // something failed, don't monitor anything.
        _has = PerfCountSet<bool>{};
    }
#endif
}
PerformanceCounter::~PerformanceCounter() {
#ifdef ZEROERR_PERF
    delete _perf;
#endif
}

PerformanceCounter& PerformanceCounter::inst() {
    static PerformanceCounter counter;
    return counter;
}

void PerformanceCounter::beginMeasure() {
#ifdef ZEROERR_PERF
    _perf->beginMeasure();
#endif
    _start = Clock::now();
}
void PerformanceCounter::endMeasure() {
    elapsed = Clock::now() - _start;
#ifdef ZEROERR_PERF
    _perf->endMeasure();
#endif
}
void PerformanceCounter::updateResults(uint64_t numIters) {
#ifdef ZEROERR_PERF
    _perf->updateResults(numIters);
#endif
}

#pragma endregion

// determines resolution of the given clock. This is done by measuring multiple times and returning
// the minimum time difference.
Clock::duration calcClockResolution(size_t numEvaluations) noexcept {
    auto              bestDuration = Clock::duration::max();
    Clock::time_point tBegin;
    Clock::time_point tEnd;
    for (size_t i = 0; i < numEvaluations; ++i) {
        tBegin = Clock::now();
        do {
            tEnd = Clock::now();
        } while (tBegin == tEnd);
        bestDuration = (std::min)(bestDuration, tEnd - tBegin);
    }
    return bestDuration;
}

// Calculates clock resolution once, and remembers the result
Clock::duration clockResolution() noexcept {
    static Clock::duration sResolution = calcClockResolution(20);
    return sResolution;
}

// helpers to get double values
template <typename T>
static inline double d(T t) noexcept {
    return static_cast<double>(t);
}
static inline double d(Clock::duration duration) noexcept {
    return std::chrono::duration_cast<std::chrono::duration<double, std::nano>>(duration).count();
}

#pragma region BenchState
struct BenchState {
    BenchState(Benchmark& bench) : bench(bench), stage(UnInit) {
        targetEpochTime = clockResolution() * bench.minimalResolutionMutipler;
        targetEpochTime = std::max(targetEpochTime, bench.mMinEpochTime);
        targetEpochTime = std::min(targetEpochTime, bench.mMaxEpochTime);
        numEpoch        = bench.epochs;
        numIteration    = 0;
        elapsed         = Clock::duration(0);
    }

    Benchmark& bench;

    enum { UnInit, WarmUp, UpScaling, Measurement } stage;

    Clock::duration elapsed;
    Clock::duration targetEpochTime;
    uint64_t        numIteration, numEpoch;

    detail::Rng mRng{1024};

    bool isCloseEnoughForMeasurements() const noexcept {
        return elapsed * 3 >= targetEpochTime * 2;
    }


    uint64_t calcBestNumIters() noexcept {
        double Elapsed               = d(elapsed);
        double TargetRuntimePerEpoch = d(targetEpochTime);
        double NewIters              = TargetRuntimePerEpoch * d(numIteration) / Elapsed;

        NewIters *= (1.0 + 0.2 * mRng.uniform01());

        // +1 for correct rounding when casting and make sure there are at least 1 iteration
        return static_cast<uint64_t>(NewIters + 1);
    }

    void upscale() {
        if (elapsed * 10 < targetEpochTime) {
            // we are far below the target runtime. Multiply iterations by 10 (with overflow check)
            if (numIteration * 10 < numIteration) {
                // overflow :-(
                printf("iterations overflow. Maybe your code got optimized away?\n");
                numIteration = 0;
                return;
            }
            if (elapsed * 100 < targetEpochTime)
                numIteration *= 100;
            else
                numIteration *= 10;
        } else {
            numIteration = calcBestNumIters();
        }
    }

    void nextStage() noexcept {
        switch (stage) {
            case UnInit:
                if (bench.warmup != 0) {
                    stage        = WarmUp;
                    numIteration = bench.warmup;
                } else if (bench.iter_per_epoch != 0) {
                    stage        = Measurement;
                    numIteration = bench.iter_per_epoch;
                } else {
                    stage        = UpScaling;
                    numIteration = 1;
                }
                break;
            case WarmUp:
                if (bench.iter_per_epoch != 0) {
                    stage        = Measurement;
                    numIteration = bench.iter_per_epoch;
                } else if (isCloseEnoughForMeasurements()) {
                    stage        = Measurement;
                    numIteration = calcBestNumIters();
                } else {
                    stage = UpScaling;
                    nextStage();
                }
                break;
            case UpScaling:
                if (isCloseEnoughForMeasurements()) {
                    stage        = Measurement;
                    numIteration = calcBestNumIters();
                } else {
                    stage = UpScaling;
                    upscale();
                }
                break;
            case Measurement:
                if (numEpoch) {
                    numEpoch--;
                } else {
                    numIteration = 0;
                }
                break;
        }
    }

    BenchResult result;
};
BenchState* createBenchState(Benchmark& benchmark) { return new BenchState(benchmark); }
void        destroyBenchState(BenchState* state) { delete state; }

size_t getNumIter(BenchState* state) {
    state->nextStage();
    return state->numIteration;
}

void runIteration(BenchState* state) {
    auto& pc       = PerformanceCounter::inst();
    state->elapsed = pc.elapsed;
    pc.updateResults(state->numIteration);

    if (state->stage == BenchState::Measurement) {
        PerfCountSet<double> pcset;
        pcset.iterations    = d(state->numIteration);
        pcset.timeElapsed() = d(state->elapsed) / pcset.iterations;

        for (int i = 1; i < 7; ++i) {
            if (pc.has().data[i]) {
                pcset.data[i] = d(pc.val().data[i]) / pcset.iterations;
            }
        }

        state->result.epoch_details.push_back(pcset);
    }
}

void moveResult(BenchState* state, std::string name) {
    auto& pc           = PerformanceCounter::inst();
    state->result.name = name;
    state->result.has  = pc.has();

    state->bench.result.push_back(state->result);
    destroyBenchState(state);
}

#pragma endregion

PerfCountSet<double> BenchResult::average() const {
    PerfCountSet<double> avg;
    for (int i = 0; i < 7; ++i) {
        if (has.data[i]) {
            double sum = 0;
            for (auto& pcset : epoch_details) {
                sum += pcset.data[i];
            }
            sum /= epoch_details.size();
            avg.data[i] = sum;
        }
    }
    return avg;
}
PerfCountSet<double> BenchResult::min() const {
    PerfCountSet<double> min;
    for (int i = 0; i < 7; ++i) {
        if (has.data[i]) {
            double min_val = std::numeric_limits<double>::max();
            for (auto& pcset : epoch_details) {
                min_val = std::min(min_val, pcset.data[i]);
            }
            min.data[i] = min_val;
        }
    }
    return min;
}
PerfCountSet<double> BenchResult::max() const {
    PerfCountSet<double> max;
    for (int i = 0; i < 7; ++i) {
        if (has.data[i]) {
            double max_val = std::numeric_limits<double>::min();
            for (auto& pcset : epoch_details) {
                max_val = std::max(max_val, pcset.data[i]);
            }
            max.data[i] = max_val;
        }
    }
    return max;
}
PerfCountSet<double> BenchResult::mean() const {
    PerfCountSet<double> mean;

    return mean;
}

void Benchmark::report() {
    static const char* names[] = {
        "elapsed(ns)", "page faults", "cpu_cycles", "ctx switch", "inst", "branch", "branch misses",
    };
    std::cerr << "" << title << ":" << std::endl;

    std::vector<std::string> headers{""};
    for (int i = 0; i < sizeof(names) / sizeof(names[0]); i++) {
        if (result[0].has.data[i]) headers.push_back(names[i]);
    }
    Table output;
    output.set_header(headers);
    for (auto& row : result) {
        auto                result = row.average();
        std::vector<double> values;
        for (int j = 0; j < 7; ++j)
            if (row.has.data[j]) values.push_back(result.data[j]);
        output.add_row(row.name, values);
    }
    std::cerr << output.str() << std::endl;
}


namespace detail {
// Windows version of doNotOptimizeAway
// see https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307
// see https://github.com/facebook/folly/blob/master/folly/Benchmark.h#L280
// see https://docs.microsoft.com/en-us/cpp/preprocessor/optimize
#if defined(_MSC_VER)
#pragma optimize("", off)
void doNotOptimizeAwaySink(void const*) {}
#pragma optimize("", on)
#endif

#pragma region Rng random number generator

Rng::Rng() : mX(0), mY(0) {
    std::random_device                      rd;
    std::uniform_int_distribution<uint64_t> dist;
    do {
        mX = dist(rd);
        mY = dist(rd);
    } while (mX == 0 && mY == 0);
}

static uint64_t splitMix64(uint64_t& state) noexcept {
    uint64_t z = (state += UINT64_C(0x9e3779b97f4a7c15));
    z          = (z ^ (z >> 30U)) * UINT64_C(0xbf58476d1ce4e5b9);
    z          = (z ^ (z >> 27U)) * UINT64_C(0x94d049bb133111eb);
    return z ^ (z >> 31U);
}

// Seeded as described in romu paper (update april 2020)
Rng::Rng(uint64_t seed) noexcept : mX(splitMix64(seed)), mY(splitMix64(seed)) {
    for (size_t i = 0; i < 10; ++i) {
        operator()();
    }
}

// only internally used to copy the RNG.
Rng::Rng(uint64_t x, uint64_t y) noexcept : mX(x), mY(y) {}

Rng Rng::copy() const noexcept { return Rng{mX, mY}; }

Rng::Rng(std::vector<uint64_t> const& data) : mX(0), mY(0) {
    if (data.size() != 2) {
        throw std::runtime_error("Rng::Rng: needed exactly 2 entries in data, but got " +
                                 std::to_string(data.size()));
    }
    mX = data[0];
    mY = data[1];
}

std::vector<uint64_t> Rng::state() const {
    std::vector<uint64_t> data(2);
    data[0] = mX;
    data[1] = mY;
    return data;
}


constexpr uint64_t(Rng::min)() { return 0; }

constexpr uint64_t(Rng::max)() { return (std::numeric_limits<uint64_t>::max)(); }

uint64_t Rng::operator()() noexcept {
    auto x = mX;

    mX = UINT64_C(15241094284759029579) * mY;
    mY = rotl(mY - x, 27);

    return x;
}

uint32_t Rng::bounded(uint32_t range) noexcept {
    uint64_t r32         = static_cast<uint32_t>(operator()());
    auto     multiresult = r32 * range;
    return static_cast<uint32_t>(multiresult >> 32U);
}

double Rng::uniform01() noexcept {
    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);
    // can't use union in c++ here for type puning, it's undefined behavior.
    // std::memcpy is optimized anyways.
    double d;
    std::memcpy(&d, &i, sizeof(double));
    return d - 1.0;
}

template <typename Container>
void Rng::shuffle(Container& container) noexcept {
    auto size = static_cast<uint32_t>(container.size());
    for (auto i = size; i > 1U; --i) {
        using std::swap;
        auto p = bounded(i);  // number in [0, i)
        swap(container[i - 1], container[p]);
    }
}

constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {
    return (x << k) | (x >> (64U - k));
}

#pragma endregion

}  // namespace detail


}  // namespace zeroerr





#if !defined(ZEROERR_ALWAYS_COLORFUL) && !defined(ZEROERR_DISABLE_COLORFUL)
namespace zeroerr {

static const char* _Reset      = "\x1b[0m";
static const char* _Bright     = "\x1b[1m";
static const char* _Dim        = "\x1b[2m";
static const char* _Underscore = "\x1b[4m";
static const char* _Blink      = "\x1b[5m";
static const char* _Reverse    = "\x1b[7m";
static const char* _Hidden     = "\x1b[8m";

static const char* _FgBlack   = "\x1b[30m";
static const char* _FgRed     = "\x1b[31m";
static const char* _FgGreen   = "\x1b[32m";
static const char* _FgYellow  = "\x1b[33m";
static const char* _FgBlue    = "\x1b[34m";
static const char* _FgMagenta = "\x1b[35m";
static const char* _FgCyan    = "\x1b[36m";
static const char* _FgWhite   = "\x1b[37m";

static const char* _BgBlack   = "\x1b[40m";
static const char* _BgRed     = "\x1b[41m";
static const char* _BgGreen   = "\x1b[42m";
static const char* _BgYellow  = "\x1b[43m";
static const char* _BgBlue    = "\x1b[44m";
static const char* _BgMagenta = "\x1b[45m";
static const char* _BgCyan    = "\x1b[46m";
static const char* _BgWhite   = "\x1b[47m";
ZEROERR_MUTEX(m);

const char* Reset      = _Reset;
const char* Bright     = _Bright;
const char* Dim        = _Dim;
const char* Underscore = _Underscore;
const char* Blink      = _Blink;
const char* Reverse    = _Reverse;
const char* Hidden     = _Hidden;

const char* FgBlack   = _FgBlack;
const char* FgRed     = _FgRed;
const char* FgGreen   = _FgGreen;
const char* FgYellow  = _FgYellow;
const char* FgBlue    = _FgBlue;
const char* FgMagenta = _FgMagenta;
const char* FgCyan    = _FgCyan;
const char* FgWhite   = _FgWhite;

const char* BgBlack   = _BgBlack;
const char* BgRed     = _BgRed;
const char* BgGreen   = _BgGreen;
const char* BgYellow  = _BgYellow;
const char* BgBlue    = _BgBlue;
const char* BgMagenta = _BgMagenta;
const char* BgCyan    = _BgCyan;
const char* BgWhite   = _BgWhite;

void disableColorOutput() {
    ZEROERR_LOCK(m);
    Reset      = "";
    Bright     = "";
    Dim        = "";
    Underscore = "";
    Blink      = "";
    Reverse    = "";
    Hidden     = "";

    FgBlack   = "";
    FgRed     = "";
    FgGreen   = "";
    FgYellow  = "";
    FgBlue    = "";
    FgMagenta = "";
    FgCyan    = "";
    FgWhite   = "";

    BgBlack   = "";
    BgRed     = "";
    BgGreen   = "";
    BgYellow  = "";
    BgBlue    = "";
    BgMagenta = "";
    BgCyan    = "";
    BgWhite   = "";
}

void enableColorOutput() {
    ZEROERR_LOCK(m);
    Reset      = _Reset;
    Bright     = _Bright;
    Dim        = _Dim;
    Underscore = _Underscore;
    Blink      = _Blink;
    Reverse    = _Reverse;
    Hidden     = _Hidden;

    FgBlack   = _FgBlack;
    FgRed     = _FgRed;
    FgGreen   = _FgGreen;
    FgYellow  = _FgYellow;
    FgBlue    = _FgBlue;
    FgMagenta = _FgMagenta;
    FgCyan    = _FgCyan;
    FgWhite   = _FgWhite;

    BgBlack   = _BgBlack;
    BgRed     = _BgRed;
    BgGreen   = _BgGreen;
    BgYellow  = _BgYellow;
    BgBlue    = _BgBlue;
    BgMagenta = _BgMagenta;
    BgCyan    = _BgCyan;
    BgWhite   = _BgWhite;
}


#ifndef ZEROERR_DISABLE_AUTO_INIT
static struct ColorInit {
    ColorInit() {
        if (isTerminalOutput(STDERR)) {
            enableColorOutput();
        } else {
            disableColorOutput();
        }
    }
} colorInit;
#endif


}  // namespace zeroerr

#endif


#include <iostream>

namespace zeroerr {


Printer& getStdoutPrinter() {
    static Printer printer(std::cout);
    return printer;
}

Printer& getStderrPrinter() {
    static Printer printer(std::cerr);
    return printer;
}

}  // namespace zeroerr

#include <cstdio>

#ifdef ZEROERR_OS_UNIX
#include <sys/ioctl.h>
#include <unistd.h>
#endif

#ifdef ZEROERR_OS_WINDOWS
#include <Windows.h>
#endif

namespace zeroerr {

#ifdef ZEROERR_OS_UNIX
bool isTerminalOutput(OutputStream stream) {
    switch (stream) {
        case STDOUT: return isatty(fileno(stdout)) != 0;
        case STDERR: return isatty(fileno(stderr)) != 0;
        default: return false;
    }
}

TerminalSize getTerminalWidth() {
    struct winsize ws;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) {
        return {80, 24};
    }
    return {ws.ws_col, ws.ws_row};
}

#endif
#ifdef ZEROERR_OS_WINDOWS
bool isTerminalOutput(OutputStream stream) {
    switch (stream) {
        case STDOUT: return GetFileType(GetStdHandle(STD_OUTPUT_HANDLE)) == FILE_TYPE_CHAR;
        case STDERR: return GetFileType(GetStdHandle(STD_ERROR_HANDLE)) == FILE_TYPE_CHAR;
        default: return false;
    }
}

TerminalSize getTerminalWidth() {
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    return {csbi.dwSize.X, csbi.dwSize.Y};
}

#endif


}  // namespace zeroerr



const char* ZEROERR_LOG_CATEGORY = "default";


namespace zeroerr {

thread_local std::vector<IContextScope*> _ZEROERR_G_CONTEXT_SCOPE_VECTOR;

LogStream::LogStream() {
    first = last = new DataBlock();
#ifndef ZEROERR_NO_THREAD_SAFE
    mutex = new std::mutex();
#endif
    setStderrLogger();
}

LogStream::~LogStream() {
    while (first) {
        DataBlock* next = first->next;
        logger->flush(first);
        delete first;
        first = next;
    }
    if (logger) delete logger;
#ifndef ZEROERR_NO_THREAD_SAFE
    delete mutex;
#endif
}

void* LogStream::alloc_block(unsigned size) {
    if (size > LogStreamMaxSize) {
        throw std::runtime_error("LogStream::push: size > LogStreamMaxSize");
    }
    ZEROERR_LOCK(*mutex);
    if (last->size + size > LogStreamMaxSize) {
        if (flush_mode == FLUSH_WHEN_FULL) {
            logger->flush(last);
            last->size = 0;    
        } else {
            last->next = new DataBlock();
            last       = last->next;
        }
    }
    void* p = last->data + last->size;
    last->size += size;
    return p;
}

void LogStream::flush() {
    // FIXME: this flush did not flush the previous data block
    logger->flush(last);
    last->size = 0;
    // std::cerr << "flush" << std::endl;
}


class FileLogger : public Logger {
public:
    FileLogger(std::string name, bool binary = true) : binary(binary) {
        if (binary) {
            file = fopen(name.c_str(), "wb");
        } else {
            file = fopen(name.c_str(), "w");
        }
    }
    ~FileLogger() {
        if (file) fclose(file);
    }
    void flush(DataBlock* msg) override {
        if (file) {
            if (binary) {
                // TODO: Design a binary format, currently, it can not work
                fwrite(msg->data, msg->size, 1, file);
            }
            for (LogMessage* p = (LogMessage*)msg->data; 
                    p < (LogMessage*)&msg->data[msg->size]; p += p->info->size) {
                auto ss = p->str(false);
                fwrite(ss.c_str(), ss.size(), 1, file);
            }
            fflush(file);
        }
    }
protected:
    FILE* file;
    bool binary;
};

class OStreamLogger : public Logger {
public:
    OStreamLogger(std::ostream& os) : os(os) {}

    void flush(DataBlock* msg) override {
        for (LogMessage* p = (LogMessage*)msg->data; 
                p < (LogMessage*)&msg->data[msg->size]; p += p->info->size) {
            os << p->str();
        }
        os.flush();
    }

protected:
    std::ostream& os;
};


LogStream& LogStream::getDefault() {
    static LogStream stream;
    return stream;
}

void LogStream::setBinFileLogger(std::string name) {
    if (logger) delete logger;
    logger = new FileLogger(name);
}

void LogStream::setFileLogger(std::string name) {
    if (logger) delete logger;
    logger = new FileLogger(name, false);
}

void LogStream::setStdoutLogger() {
    if (logger) delete logger;
    logger = new OStreamLogger(std::cout);
}

void LogStream::setStderrLogger() {
    if (logger) delete logger;
    logger = new OStreamLogger(std::cerr);
}


static LogSeverity                     LogLevel;

static std::unordered_set<std::string> LogCategory;
static std::vector<std::string>        AllLogCategory;


void setLogLevel(LogSeverity level) {
    LogLevel = level;
}

void setLogCategory(const char* categories) {
    LogCategory.clear();
    std::string str = categories;
    std::string cat;
    for (auto c : str) {
        if (c == ',') {
            LogCategory.insert(cat);
            cat.clear();
        } else {
            cat.push_back(c);
        }
    }
    if (!cat.empty()) {
        LogCategory.insert(cat);
    }
}


}  // namespace zeroerr





#include <algorithm>
#include <map>
#include <sstream>

namespace zeroerr {

// clang-format off

static Table::Style ASCII{
"+","-","-","+",
"|"," ","|","|",
"|","-","+","|",
"|"," ","|","|",
"|","-","+","|",
"|","-","+","|",
"|"," ","|","|",
"+","-","-","+",
};

static Table::Style ASCII2{
"+","-","+","+",
"|"," ","|","|",
"+","-","+","+",
"|"," ","|","|",
"+","-","+","+",
"+","-","+","+",
"|"," ","|","|",
"+","-","+","+",
};

static Table::Style ASCII_DOUBLE_HEAD{
"+","-","+","+",
"|"," ","|","|",
"+","=","+","+",
"|"," ","|","|",
"+","-","+","+",
"+","-","+","+",
"|"," ","|","|",
"+","-","+","+",
};

static Table::Style SQUARE{
"┌","─","┬","┐",
"│"," ","│","│",
"├","─","┼","┤",
"│"," ","│","│",
"├","─","┼","┤",
"├","─","┼","┤",
"│"," ","│","│",
"└","─","┴","┘",
};

static Table::Style SQUARE_DOUBLE_HEAD{
"┌","─","┬","┐",
"│"," ","│","│",
"╞","═","╪","╡",
"│"," ","│","│",
"├","─","┼","┤",
"├","─","┼","┤",
"│"," ","│","│",
"└","─","┴","┘",
};

static Table::Style MINIMAL{
" "," ","╷"," ",
" "," ","│"," ",
"╶","─","┼","╴",
" "," ","│"," ",
"╶","─","┼","╴",
"╶","─","┼","╴",
" "," ","│"," ",
" "," ","╵"," ",
};


static Table::Style MINIMAL_HEAVY_HEAD{
" "," ","╷"," ",
" "," ","│"," ",
"╺","━","┿","╸",
" "," ","│"," ",
"╶","─","┼","╴",
"╶","─","┼","╴",
" "," ","│"," ",
" "," ","╵"," ",
};

static Table::Style MINIMAL_DOUBLE_HEAD{
" "," ","╷"," ",
" "," ","│"," ",
" ","═","╪"," ",
" "," ","│"," ",
" ","─","┼"," ",
" ","─","┼"," ",
" "," ","│"," ",
" "," ","╵"," ",
};


static Table::Style SIMPLE{
" "," "," "," ",
" "," "," "," ",
" ","─","─"," ",
" "," "," "," ",
" "," "," "," ",
" ","─","─"," ",
" "," "," "," ",
" "," "," "," ",
};

static Table::Style SIMPLE_HEAD{
" "," "," "," ",
" "," "," "," ",
" ","─","─"," ",
" "," "," "," ",
" "," "," "," ",
" "," "," "," ",
" "," "," "," ",
" "," "," "," ",
};


static Table::Style SIMPLE_HEAVY{
" "," "," "," ",
" "," "," "," ",
" ","━","━"," ",
" "," "," "," ",
" "," "," "," ",
" ","━","━"," ",
" "," "," "," ",
" "," "," "," ",
};


static Table::Style HORIZONTALS{
" ","─","─"," ",
" "," "," "," ",
" ","─","─"," ",
" "," "," "," ",
" ","─","─"," ",
" ","─","─"," ",
" "," "," "," ",
" ","─","─"," ",
};

static Table::Style ROUNDED{
"╭","─","┬","╮",
"│"," ","│","│",
"├","─","┼","┤",
"│"," ","│","│",
"├","─","┼","┤",
"├","─","┼","┤",
"│"," ","│","│",
"╰","─","┴","╯",
};

static Table::Style HEAVY{
"┏","━","┳","┓",
"┃"," ","┃","┃",
"┣","━","╋","┫",
"┃"," ","┃","┃",
"┣","━","╋","┫",
"┣","━","╋","┫",
"┃"," ","┃","┃",
"┗","━","┻","┛",
};

static Table::Style HEAVY_EDGE{
"┏","━","┯","┓",
"┃"," ","│","┃",
"┠","─","┼","┨",
"┃"," ","│","┃",
"┠","─","┼","┨",
"┠","─","┼","┨",
"┃"," ","│","┃",
"┗","━","┷","┛",
};

static Table::Style HEAVY_HEAD{
"┏","━","┳","┓",
"┃"," ","┃","┃",
"┡","━","╇","┩",
"│"," ","│","│",
"├","─","┼","┤",
"├","─","┼","┤",
"│"," ","│","│",
"└","─","┴","┘",
};

static Table::Style DOUBLE{
"╔","═","╦","╗",
"║"," ","║","║",
"╠","═","╬","╣",
"║"," ","║","║",
"╠","═","╬","╣",
"╠","═","╬","╣",
"║"," ","║","║",
"╚","═","╩","╝",
};

static Table::Style DOUBLE_EDGE{
"╔","═","╤","╗",
"║"," ","│","║",
"╟","─","┼","╢",
"║"," ","│","║",
"╟","─","┼","╢",
"╟","─","┼","╢",
"║"," ","│","║",
"╚","═","╧","╝",
};

// clang-format on

struct StyleManager {
    std::map<std::string, Table::Style> styles;

    static StyleManager& instance() {
        static StyleManager instance;
        instance.styles["ascii"]               = ASCII;
        instance.styles["ascii2"]              = ASCII2;
        instance.styles["ascii_double_head"]   = ASCII_DOUBLE_HEAD;
        instance.styles["square"]              = SQUARE;
        instance.styles["square_double_head"]  = SQUARE_DOUBLE_HEAD;
        instance.styles["simple"]              = SIMPLE;
        instance.styles["simple_head"]         = SIMPLE_HEAD;
        instance.styles["simple_heavy"]        = SIMPLE_HEAVY;
        instance.styles["horizontal"]          = HORIZONTALS;
        instance.styles["rounded"]             = ROUNDED;
        instance.styles["heavy"]               = HEAVY;
        instance.styles["heavy_edge"]          = HEAVY_EDGE;
        instance.styles["heavy_head"]          = HEAVY_HEAD;
        instance.styles["double"]              = DOUBLE;
        instance.styles["double_edge"]         = DOUBLE_EDGE;
        instance.styles["minimal"]             = MINIMAL;
        instance.styles["minimal_heavy_head"]  = MINIMAL_HEAVY_HEAD;
        instance.styles["minimal_double_head"] = MINIMAL_DOUBLE_HEAD;
        return instance;
    }
};

void Table::registerStyle(std::string name, Table::Style style) {
    StyleManager::instance().styles[name] = style;
}
Table::Style Table::getStyle(std::string name) { return StyleManager::instance().styles[name]; }

#define left  (c.show_lr_border ? s.m_args[p] : "")
#define space s.m_args[p + 1]
#define bar   (c.show_col_split ? s.m_args[p + 2] : s.m_args[p + 1])
#define right (c.show_lr_border ? s.m_args[p + 3] : "")

#define last (i == header.size() - 1)
#define for_row          \
    if (!skip_lb)        \
        ss << std::endl; \
    else                 \
        skip_lb = false; \
    ss << left;          \
    for (int i = 0; i < header.size(); ++i)


inline std::string _rept(unsigned k, std::string j, Table::Style& s) {
    std::stringstream ss;
    for (unsigned i = 0; i < k; i++) {
        ss << j;
    }
    return ss.str();
}

#define rep(k, t) _rept(k, t, s)
#define remain(k) (col_width[i] - k.size())

std::string Table::str(Config c, Table::Style s) {
    std::stringstream ss;

    for (auto& row : cells) {
        REQUIRE(row.size() == header.size());
    }

    if (col_width.size() == 0) {
        for (int i = 0; i < header.size(); ++i) {
            unsigned max_width = 0;
            for (auto& row : cells) {
                max_width = std::max<unsigned>(row[i].size(), max_width);
            }
            max_width = std::max<unsigned>(max_width, header[i].size());
            col_width.push_back(max_width);
        }
    }

    int  p;
    bool skip_lb = true;
    // Header
    if (c.show_tb_border) {
        p = 0;
        for_row { ss << rep(col_width[i] + 2, space) << (last ? right : bar); }
    }

    p = 4;
    for_row {
        REQUIRE(col_width[i] >= header[i].size());
        ss << space << rep(remain(header[i]), space) << header[i] << space << (last ? right : bar);
    }

    if (c.show_header_split) {
        p = 8;
        for_row { ss << rep(col_width[i] + 2, space) << (last ? right : bar); }
    }

    p = 12;
    // Body
    bool first = true;
    for (auto& row : cells) {
        if (!first && c.show_row_split) {
            p += 4;
            for_row { ss << rep(col_width[i] + 2, space) << (last ? right : bar); }
            p -= 4;
        } else
            first = false;
        for_row {
            REQUIRE(col_width[i] >= row[i].size());
            ss << space << rep(remain(row[i]), space) << row[i] << space << (last ? right : bar);
        }
    }

    if (footer.size() != 0) {
    }

    // Bottom
    if (c.show_tb_border) {
        p = 28;
        for_row { ss << rep(col_width[i] + 2, space) << (last ? right : bar); }
    }
    return ss.str();
}


}  // namespace zeroerr






#include <iomanip>
#include <iostream>
#include <ostream>
#include <set>
#include <string>
#include <vector>

namespace zeroerr {

namespace detail {
static std::set<TestCase>& getRegisteredTests();
}

int TestContext::add(TestContext&& local) {
    int type = 0;
    if (local.failed_as == 0 && local.warning_as == 0) {
        passed += 1;
    } else if (local.failed_as == 0) {
        warning += 1;
        type = 1;
    } else {
        failed += 1;
        type = 2;
    }
    passed_as += local.passed_as;
    warning_as += local.warning_as;
    failed_as += local.failed_as;

    memset(&local, 0, sizeof(local));
    return type;
}

void TestContext::save_output() {
    std::fstream file;
    file.open("output.txt", std::ios::in);
    std::stringbuf* outbuf = static_cast<std::stringbuf*>(std::cerr.rdbuf());
    if (file.is_open()) {
        std::stringstream buffer;
        buffer << file.rdbuf();
        if (buffer.str() != outbuf->str()) {
            std::cerr << "Output mismatch" << std::endl;
            throw std::runtime_error("Output mismatch");
        } else {
            std::cerr << "Output match" << std::endl;
        }
    } else {
        file.open("output.txt", std::ios::out);
        file << outbuf->str();
    }
    file.close();
}

static inline std::string getFileName(std::string file) {
    std::string fileName(file);
    auto        p = fileName.find_last_of('/');
    if (p != std::string::npos) fileName = fileName.substr(p + 1);
    return fileName;
}

SubCaseReg::SubCaseReg(std::string name, std::string file, unsigned line, TestContext* context)
    : context(context) {
    std::cerr << "SUBCASE " << Dim << "[" << getFileName(file) << ":" << line << "] " << Reset
              << FgCyan << name << Reset << std::endl;
}

void SubCaseReg::operator<<(std::function<void(TestContext*)> op) {
    TestContext local;
    try {
        op(&local);
    } catch (const AssertionData& e) {
    } catch (const std::exception& e) {
        if (local.failed_as == 0) {
            local.failed_as = 1;
        }
    }
    context->add(std::move(local));
}

UnitTest& UnitTest::parseArgs(int argc, char** argv) { return *this; }


static std::string insertIndentation(std::string str) {
    std::stringstream result;
    std::stringstream ss(str);

    std::string line;
    while (std::getline(ss, line)) {
        result << line << std::endl << "    ";
    }

    return result.str();
}

int UnitTest::run() {
    setlocale(LC_ALL, "en_US.utf8");
    std::cerr << "ZeroErr Unit Test" << std::endl;
    TestContext     context, sum;
    std::stringbuf* new_buf = new std::stringbuf();
    for (auto& tc : detail::getRegisteredTests()) {
        std::cerr << "TEST CASE " << Dim << "[" << getFileName(tc.file) << ":" << tc.line << "] "
                  << Reset << FgCyan << tc.name << Reset << std::endl;
        std::streambuf* orig_buf = std::cerr.rdbuf();
        std::cerr.rdbuf(new_buf);
        std::cerr << std::endl;
        try {
            tc.func(&context);  // run the test case
        } catch (const AssertionData& e) {
        } catch (const std::exception& e) {
            if (context.failed_as == 0) {
                context.failed_as = 1;
            }
        }
        int type = sum.add(std::move(context));
        std::cerr.rdbuf(orig_buf);
        if (!(silent && type == 0)) std::cerr << insertIndentation(new_buf->str()) << std::endl;
        new_buf->str("");
    }
    delete new_buf;
    std::cerr << "----------------------------------------------------------------" << std::endl;
    std::cerr << "             " << FgGreen << "PASSED" << Reset << "   |   " << FgYellow
              << "WARNING" << Reset << "   |   " << FgRed << "FAILED" << Reset << "   |   " << Dim
              << "SKIPPED" << Reset << std::endl;
    std::cerr << "TEST CASE:   " << std::setw(6) << sum.passed << "       " << std::setw(7)
              << sum.warning << "       " << std::setw(6) << sum.failed << "       " << std::setw(7)
              << sum.skipped << std::endl;
    std::cerr << "ASSERTION:   " << std::setw(6) << sum.passed_as << "       " << std::setw(7)
              << sum.warning_as << "       " << std::setw(6) << sum.failed_as << "       "
              << std::setw(7) << sum.skipped_as << std::endl;
    return 0;
}

// sorted by file names and line numbers
bool TestCase::operator<(const TestCase& rhs) const {
    return (file < rhs.file) || (file == rhs.file && line < rhs.line);
}

namespace detail {

static std::set<TestCase>& getRegisteredTests() {
    static std::set<TestCase> data;
    return data;
}

regTest::regTest(const TestCase& tc) { getRegisteredTests().insert(tc); }

static std::set<IReporter*>& getRegisteredReporters() {
    static std::set<IReporter*> data;
    return data;
}

regReporter::regReporter(IReporter* reporter) { getRegisteredReporters().insert(reporter); }

}  // namespace detail


class ConsoleReporter : public IReporter {
public:
};


class XmlEncode;
class XmlWriter;

class XmlReporter : public IReporter {
public:
};

class JUnitReporter : public IReporter {
public:
};


// =================================================================================================
// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
// =================================================================================================
class XmlEncode {
public:
    enum ForWhat { ForTextNodes, ForAttributes };

    XmlEncode(std::string const& str, ForWhat forWhat = ForTextNodes);

    void encodeTo(std::ostream& os) const;

    friend std::ostream& operator<<(std::ostream& os, XmlEncode const& xmlEncode);

private:
    std::string m_str;
    ForWhat     m_forWhat;
};

class XmlWriter {
public:
    class ScopedElement {
    public:
        ScopedElement(XmlWriter* writer);

        ScopedElement(ScopedElement&& other) noexcept;
        ScopedElement& operator=(ScopedElement&& other) noexcept;

        ~ScopedElement();

        ScopedElement& writeText(std::string const& text, bool indent = true);

        template <typename T>
        ScopedElement& writeAttribute(std::string const& name, T const& attribute) {
            m_writer->writeAttribute(name, attribute);
            return *this;
        }

    private:
        mutable XmlWriter* m_writer = nullptr;
    };

    XmlWriter(std::ostream& os = std::cerr);
    ~XmlWriter();

    XmlWriter(XmlWriter const&)            = delete;
    XmlWriter& operator=(XmlWriter const&) = delete;

    XmlWriter& startElement(std::string const& name);

    ScopedElement scopedElement(std::string const& name);

    XmlWriter& endElement();

    XmlWriter& writeAttribute(std::string const& name, std::string const& attribute);

    XmlWriter& writeAttribute(std::string const& name, const char* attribute);

    XmlWriter& writeAttribute(std::string const& name, bool attribute);

    template <typename T>
    XmlWriter& writeAttribute(std::string const& name, T const& attribute) {
        std::stringstream rss;
        rss << attribute;
        return writeAttribute(name, rss.str());
    }

    XmlWriter& writeText(std::string const& text, bool indent = true);

    void ensureTagClosed();

    void writeDeclaration();

private:
    void newlineIfNecessary();

    bool                     m_tagIsOpen    = false;
    bool                     m_needsNewline = false;
    std::vector<std::string> m_tags;
    std::string              m_indent;
    std::ostream&            m_os;
};

using uchar = unsigned char;

static size_t trailingBytes(unsigned char c) {
    if ((c & 0xE0) == 0xC0) {
        return 2;
    }
    if ((c & 0xF0) == 0xE0) {
        return 3;
    }
    if ((c & 0xF8) == 0xF0) {
        return 4;
    }
    throw std::runtime_error("Invalid multibyte utf-8 start byte encountered");
}

static uint32_t headerValue(unsigned char c) {
    if ((c & 0xE0) == 0xC0) {
        return c & 0x1F;
    }
    if ((c & 0xF0) == 0xE0) {
        return c & 0x0F;
    }
    if ((c & 0xF8) == 0xF0) {
        return c & 0x07;
    }
    throw std::runtime_error("Invalid multibyte utf-8 start byte encountered");
}

static void hexEscapeChar(std::ostream& os, unsigned char c) {
    std::ios_base::fmtflags f(os.flags());
    os << "\\x" << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
       << static_cast<int>(c);
    os.flags(f);
}

XmlEncode::XmlEncode(std::string const& str, ForWhat forWhat) : m_str(str), m_forWhat(forWhat) {}

void XmlEncode::encodeTo(std::ostream& os) const {
    // Apostrophe escaping not necessary if we always use " to write attributes
    // (see: https://www.w3.org/TR/xml/#syntax)

    for (std::size_t idx = 0; idx < m_str.size(); ++idx) {
        uchar c = m_str[idx];
        switch (c) {
            case '<': os << "&lt;"; break;
            case '&': os << "&amp;"; break;

            case '>':
                // See: https://www.w3.org/TR/xml/#syntax
                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
                    os << "&gt;";
                else
                    os << c;
                break;

            case '\"':
                if (m_forWhat == ForAttributes)
                    os << "&quot;";
                else
                    os << c;
                break;

            default:
                // Check for control characters and invalid utf-8

                // Escape control characters in standard ascii
                // see
                // https://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
                    hexEscapeChar(os, c);
                    break;
                }

                // Plain ASCII: Write it to stream
                if (c < 0x7F) {
                    os << c;
                    break;
                }

                // UTF-8 territory
                // Check if the encoding is valid and if it is not, hex escape bytes.
                // Important: We do not check the exact decoded values for validity, only the
                // encoding format First check that this bytes is a valid lead byte: This means that
                // it is not encoded as 1111 1XXX Or as 10XX XXXX
                if (c < 0xC0 || c >= 0xF8) {
                    hexEscapeChar(os, c);
                    break;
                }

                auto encBytes = trailingBytes(c);
                // Are there enough bytes left to avoid accessing out-of-bounds memory?
                if (idx + encBytes - 1 >= m_str.size()) {
                    hexEscapeChar(os, c);
                    break;
                }
                // The header is valid, check data
                // The next encBytes bytes must together be a valid utf-8
                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
                bool     valid = true;
                uint32_t value = headerValue(c);
                for (std::size_t n = 1; n < encBytes; ++n) {
                    uchar nc = m_str[idx + n];
                    valid &= ((nc & 0xC0) == 0x80);
                    value = (value << 6) | (nc & 0x3F);
                }

                if (
                    // Wrong bit pattern of following bytes
                    (!valid) ||
                    // Overlong encodings
                    (value < 0x80) ||
                    (value < 0x800 &&
                     encBytes > 2) ||  // removed "0x80 <= value &&" because redundant
                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
                    // Encoded value out of range
                    (value >= 0x110000)) {
                    hexEscapeChar(os, c);
                    break;
                }

                // If we got here, this is in fact a valid(ish) utf-8 sequence
                for (std::size_t n = 0; n < encBytes; ++n) {
                    os << m_str[idx + n];
                }
                idx += encBytes - 1;
                break;
        }
    }
}

std::ostream& operator<<(std::ostream& os, XmlEncode const& xmlEncode) {
    xmlEncode.encodeTo(os);
    return os;
}

XmlWriter::ScopedElement::ScopedElement(XmlWriter* writer) : m_writer(writer) {}

XmlWriter::ScopedElement::ScopedElement(ScopedElement&& other) noexcept : m_writer(other.m_writer) {
    other.m_writer = nullptr;
}

XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=(ScopedElement&& other) noexcept {
    if (m_writer) {
        m_writer->endElement();
    }
    m_writer       = other.m_writer;
    other.m_writer = nullptr;
    return *this;
}


XmlWriter::ScopedElement::~ScopedElement() {
    if (m_writer) m_writer->endElement();
}

XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText(std::string const& text,
                                                              bool               indent) {
    m_writer->writeText(text, indent);
    return *this;
}

XmlWriter::XmlWriter(std::ostream& os) : m_os(os) {}

XmlWriter::~XmlWriter() {
    while (!m_tags.empty()) endElement();
}

XmlWriter& XmlWriter::startElement(std::string const& name) {
    ensureTagClosed();
    newlineIfNecessary();
    m_os << m_indent << '<' << name;
    m_tags.push_back(name);
    m_indent += "  ";
    m_tagIsOpen = true;
    return *this;
}

XmlWriter::ScopedElement XmlWriter::scopedElement(std::string const& name) {
    ScopedElement scoped(this);
    startElement(name);
    return scoped;
}

XmlWriter& XmlWriter::endElement() {
    newlineIfNecessary();
    m_indent = m_indent.substr(0, m_indent.size() - 2);
    if (m_tagIsOpen) {
        m_os << "/>";
        m_tagIsOpen = false;
    } else {
        m_os << m_indent << "</" << m_tags.back() << ">";
    }
    m_os << std::endl;
    m_tags.pop_back();
    return *this;
}

XmlWriter& XmlWriter::writeAttribute(std::string const& name, std::string const& attribute) {
    if (!name.empty() && !attribute.empty())
        m_os << ' ' << name << "=\"" << XmlEncode(attribute, XmlEncode::ForAttributes) << '"';
    return *this;
}

XmlWriter& XmlWriter::writeAttribute(std::string const& name, const char* attribute) {
    if (!name.empty() && attribute && attribute[0] != '\0')
        m_os << ' ' << name << "=\"" << XmlEncode(attribute, XmlEncode::ForAttributes) << '"';
    return *this;
}

XmlWriter& XmlWriter::writeAttribute(std::string const& name, bool attribute) {
    m_os << ' ' << name << "=\"" << (attribute ? "true" : "false") << '"';
    return *this;
}

XmlWriter& XmlWriter::writeText(std::string const& text, bool indent) {
    if (!text.empty()) {
        bool tagWasOpen = m_tagIsOpen;
        ensureTagClosed();
        if (tagWasOpen && indent) m_os << m_indent;
        m_os << XmlEncode(text);
        m_needsNewline = true;
    }
    return *this;
}

void XmlWriter::ensureTagClosed() {
    if (m_tagIsOpen) {
        m_os << ">" << std::endl;
        m_tagIsOpen = false;
    }
}

void XmlWriter::writeDeclaration() { m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"; }

void XmlWriter::newlineIfNecessary() {
    if (m_needsNewline) {
        m_os << std::endl;
        m_needsNewline = false;
    }
}

// =================================================================================================
// End of copy-pasted code from Catch
// =================================================================================================


}  // namespace zeroerr


int main(int argc, char** argv) { return zeroerr::UnitTest().parseArgs(argc, argv).run(); }

#endif // ZEROERR_IMPLEMENTATION
